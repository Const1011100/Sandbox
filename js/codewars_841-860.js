//*-Task №841 Cartesian coordinates from degree angle (7kyu)
/*
Напишіть просту функцію, яка приймає полярні координати (кут у градусах та радіус)
та повертає еквівалентні декартові координати.

Наприклад:

coordinates(90,1)
=> (0.0, 1.0)

coordinates(45, 1)
=> (0.7071067812, 0.7071067812)
*/

// Мій варіантfunction {
function coordinates(angleDegrees, radius) {
  const angleRadians = (angleDegrees * Math.PI) / 180;
  const x = radius * Math.cos(angleRadians);
  const y = radius * Math.sin(angleRadians);

  return [parseFloat(x.toFixed(10)), parseFloat(y.toFixed(10))];
}
// Цікаві варіанти з Codewars
function coordinates_(d, r) {
  var θ = (d * Math.PI) / 180;
  return [+(r * Math.cos(θ)).toFixed(10), +(r * Math.sin(θ)).toFixed(10)];
}
// ================================================================================================
// ================================================================================================
//*-Task №842 Array Mash (7kyu)
/*
Об'єднайте 2 масиви разом так, щоб повернутий масив містив чергувані елементи цих двох масивів.
Обидва масиви завжди будуть однакової довжини.

Наприклад: [1,2,3] + ['a','b','c'] = [1, 'a', 2, 'b', 3, 'c']
*/

// Мій варіант
function arrayMash(array1, array2) {
  const result = [];
  for (let i = 0; i < array1.length; i++) {
    result.push(array1[i]);
    result.push(array2[i]);
  }
  return result;
}
// Цікаві варіанти з Codewars
function arrayMash_(array1, array2) {
  let newArr = [];
  for (let i = 0; i < array1.length; i++) {
    newArr.push(array1[i], array2[i]);
  }
  return newArr;
}
// ================================================================================================
// ================================================================================================
//*-Task №843 Array comparator (7kyu)
/*
У цьому ката у вас є два масиви, кожен масив містить лише унікальні елементи.
Ваше завдання — обчислити кількість елементів у першому масиві, які також присутні в другому масиві.
*/

// Мій варіант
function matchArrays(v, r) {
  return v.filter((e) => r.includes(e)).length;
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №844 Dropcaps (7kyu)
/*
DropCaps означає, що перша літера початкового слова абзацу має бути написана великою літерою,
а решта — малою, як ви бачите в газеті.

Але для різноманітності давайте зробимо це для кожного слова заданого рядка.
Ваше завдання — писати з великої літери кожне слово, довжина якого перевищує 2,
залишаючи менші слова такими, як вони є.

*має працювати також з початковими та кінцевими пробілами та великими літерами.

"apple" => "Apple"
"apple of banana" => "Apple of Banana"
"one space" => "One Space"
"space WALK " => " Space Walk "
Примітка: вам буде надано принаймні одне слово, і ви повинні прийняти рядок як вхідні дані та
повернути рядок як вихідні.
*/

// Мій варіант
function dropCap(n) {
  return n.replace(/\b\w{3,}\b/g, function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
  });
}
// Цікаві варіанти з Codewars
function dropCap_(n) {
  n = n.split(' ');
  for (var i = 0; i < n.length; i++) {
    if (n[i].length > 2) {
      n[i] = n[i].slice(0, 1).toUpperCase() + n[i].slice(1).toLowerCase();
    }
  }
  return n.join(' ');
}
// ================================================================================================
// ================================================================================================
//*-Task №845 CompoundArray (7kyu)
/*
Вам потрібно створити метод "compoundArray", який має приймати на вхід два цілочисельні масиви різної
довжини та повертати один цілочисельний масив з номерами обох масивів, перетасованими один за одним.

Вхідні дані - [1,2,3,4,5,6] та [9,8,7,6]
Вихідні дані - [1,9,2,8,3,7,4,6,5,6]
*/

// Мій варіант
function compoundArray(a, b) {
  const result = [];
  const length = Math.max(a.length, b.length);
  for (let i = 0; i < length; i++) {
    if (a.length >= i + 1) {
      result.push(a[i]);
    }
    if (b.length >= i + 1) {
      result.push(b[i]);
    }
  }
  return result;
}
// Цікаві варіанти з Codewars
function compoundArray_(a, b) {
  var result = [];
  for (var i = 0; i < Math.max(a.length, b.length); i++) {
    if (!isNaN(a[i])) result.push(a[i]);
    if (!isNaN(b[i])) result.push(b[i]);
  }
  return result;
}
// ================================================================================================
// ================================================================================================
//*-Task №846 Thinking & Testing : Uniq or not Uniq (7kyu)
/*
Без історії
Без опису
Тільки шляхом роздумів та тестування
Подивіться на результат тестового випадку, вгадайте код!
*/

// Мій варіант
function testit(a, b) {
  return [...new Set(a), ...new Set(b)].sort((a, b) => a - b);
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
