//*-Task №701 (7kyu)
/*
У вашому класі ви розпочали уроки арифметичної прогресії. Оскільки ви також програміст,
ви вирішили написати функцію, яка повертатиме перші n елементів послідовності із заданою
спільною різницею d та першим елементом a. Зверніть увагу, що різниця може дорівнювати нулю!

Результатом має бути рядок чисел, розділених комою та пробілом.

Приклад
# first element: 1, difference: 2, how many: 5
arithmetic_sequence_elements(1, 2, 5) == "1, 3, 5, 7, 9"
*/

// Мій варіант
function arithmeticSequenceElements(a, d, n) {
  let result = [];
  for (let i = 0; i < n; i++) {
    result.push(a + i * d);
  }
  return result.join(', ');
}
// Цікаві варіанти з Codewars
function arithmeticSequenceElements_(a, r, n) {
  var ret = [a];
  while (--n) ret.push((a += r));
  return ret.join(', ');
}
// ================================================================================================
// ================================================================================================
//*-Task №702 Basic Sequence Practice (7kyu)
/*
Послідовність або ряд у математиці — це рядок об'єктів, таких як числа, які відповідають певному
шаблону. Окремі елементи послідовності називаються членами.
Простий приклад — 3, 6, 9, 12, 15, 18, 21, ..., де шаблон такий: «додати 3 до попереднього члена».

У цьому ката ми будемо використовувати складнішу послідовність: 0, 1, 3, 6, 10, 15, 21, 28, ...
Ця послідовність генерується за шаблоном: «n-й член — це сума чисел від 0 до n включно».
[ 0,  1,    3,      6,   ...]
  0  0+1  0+1+2  0+1+2+3

Ваше завдання
Виконайте функцію, яка приймає ціле число n та повертає масив довжини abs(n) + 1 з арифметичного ряду,
описаного вище. Коли n < 0, поверніть послідовність з від'ємними членами.

Приклади
 5  -->  [0,  1,  3,  6,  10,  15]
-5  -->  [0, -1, -3, -6, -10, -15]
 7  -->  [0,  1,  3,  6,  10,  15,  21,  28]
*/

// Мій варіант
function sumOfN(n) {
  const result = [];
  if (n < 0) {
    for (let i = -1; i >= n - 1; i--) {
      const triangularNumber = ((i * (i + 1)) / 2) * -1;
      result.push(triangularNumber);
    }
  }
  for (let i = 0; i <= n; i++) {
    const triangularNumber = (i * (i + 1)) / 2; // формула Трикутного числа
    result.push(triangularNumber);
  }
  return result;
}
// Цікаві варіанти з Codewars
function sumOfN_(n) {
  var array = [];
  array[0] = 0;
  for (var i = 1; i < Math.abs(n) + 1; i++) {
    if (n > 0) array[i] = array[i - 1] + i;
    else array[i] = array[i - 1] - i;
  }
  return array;
}
//
function sumOfN__(n) {
  for (var i = 0, list = []; i <= Math.abs(n); i++) {
    list.push((list[i - 1] || 0) + i * (n < 0 ? -1 : 1));
  }

  return list;
}
// ================================================================================================
// ================================================================================================
//*-Task №703 Complete The Pattern #1 (7kyu)
/*
Вам потрібно написати функцію-шаблон, яка повертає наступний шаблон до n рядків.

Якщо n < 1, то має повертатися "", тобто порожній рядок.
У шаблоні немає пробілів.
Шаблон:
1
22
333
....
.....
nnnnnn

Приклади:
pattern(5):
1
22
333
4444
55555
*/

// Мій варіант
function pattern(n) {
  return Array.from({ length: n }, (_, i) => String(i + 1).repeat(i + 1)).join(
    '\n'
  );
}

// Цікаві варіанти з Codewars
function pattern_(n) {
  var res = [],
    i;
  for (i = 1; i <= n; i++) {
    res.push(Array(i + 1).join(i));
  }
  return res.join('\n');
}
// ================================================================================================
// ================================================================================================
//*-Task №704 Jumping Number (Special Numbers Series #4) (7kyu)
/*
Стрибкове число — це число, всі сусідні цифри якого відрізняються на 1.
Дано число. Знайдіть, чи воно стрибає, чи ні.

Передане число завжди додатне.
Повернути результат у вигляді рядка (String).
Різниця між «9» та «0» не вважається 1.
Усі одноцифрові числа вважаються числами зі стрибками.

jumpingNumber(9) ==> return "Jumping!!"
jumpingNumber(79) ==> return "Not!!"
jumpingNumber(23) ==> return "Jumping!!"
jumpingNumber(556847) ==> return "Not!!"
jumpingNumber(4343456) ==> return "Jumping!!"
jumpingNumber(89098) ==> return "Not!!"
jumpingNumber(32) ==> return "Jumping!!"
*/

// Мій варіант
function jumpingNumber(n) {
  if (n < 10) {
    return 'Jumping!!';
  }

  const arr = `${n}`.split('').map(Number);

  for (let i = 1; i < arr.length; i++) {
    if (Math.abs(arr[i] - arr[i - 1]) !== 1) {
      return 'Not!!';
    }
  }

  return 'Jumping!!';
}
// Цікаві варіанти з Codewars
const jumpingNumber_ = (n) =>
  n.toString().split``.every((e, i, a) => i < 1 || Math.abs(e - a[i - 1]) === 1)
    ? 'Jumping!!'
    : 'Not!!';
// ================================================================================================
// ================================================================================================
//*-Task №705 Sum ALL the arrays! (7kyu)
/*
Вам задано масив значень.
Підсумуйте всі числові значення в масиві та будь-які вкладені масиви (до будь-якої глибини).
Ігноруйте всі інші типи значень.
*/

// Мій варіант
function arraySum(arr) {
  let sum = 0;

  arr.forEach((element) => {
    if (Array.isArray(element)) {
      sum += arraySum(element);
    } else if (typeof element === 'number') {
      sum += element;
    }
  });

  return sum;
}

// Цікаві варіанти з Codewars
function arraySum_(arr) {
  return arr.reduce(
    (n, x) => n + (Array.isArray(x) ? arraySum(x) : isNaN(x) ? 0 : x),
    0
  );
}
// ================================================================================================
// ================================================================================================
//*-Task №706 Unique Sum (7kyu)
/*
Враховуючи список цілочисельних значень, ваше завдання — повернути суму цих значень; однак, якщо
одне й те саме ціле значення зустрічається у списку кілька разів, ви можете врахувати його у своїй
сумі лише один раз.

Наприклад:
[ 1, 2, 3] ==> 6
[ 1, 3, 8, 1, 8] ==> 12
[ -1, -1, 5, 2, -7] ==> -1
[] ==> null
*/

// Мій варіант
function uniqueSum(lst) {
  if (lst.length < 1) {
    return null;
  }
  let uniqueValues = new Set(lst);
  let sum = 0;
  for (let value of uniqueValues) {
    sum += value;
  }
  return sum;
}
// Цікаві варіанти з Codewars
function uniqueSum_(lst) {
  return [...new Set(lst)].reduce((a, b) => a + b, null);
}
// ================================================================================================
// ================================================================================================
//*-Task №707 Substring fun (7kyu)
/*
Виконайте функцію, яка приймає масив слів.

Ви повинні об'єднати n-ту літеру з кожного слова, щоб створити нове слово, яке має бути повернуто
як рядок, де n – це позиція слова у списку.

Наприклад:
["yoda", "best", "has"]  -->  "yes"
  ^        ^        ^
  n=0     n=1     n=2

Примітка: Тестові випадки містять лише коректні вхідні дані, тобто масив рядків або порожній масив;
і кожне слово матиме достатню кількість літер.
*/

// Мій варіант
function nthChar(words) {
  let word = '';
  for (let i = 0; i < words.length; i++) {
    word += words[i][i];
  }
  return word;
}
// Цікаві варіанти з Codewars
const nthChar_ = (words) => words.map((word, index) => word[index]).join('');
//
const nthChar__ = (words) => words.reduce((a, b, index) => a + b[index], '');
// ================================================================================================
// ================================================================================================
//*-Task №708 Sum a list but ignore any duplicates (7kyu)
/*
Будь ласка, напишіть функцію, яка підсумовує список, але ігнорує будь-які дубліковані елементи у списку.

Наприклад, для списку [3, 4, 3, 6] функція повинна повертати 10,
а для списку [1, 10, 3, 10, 10] функція повинна повертати 4.
*/

// Мій варіант
function sumNoDuplicates(numList) {
  const counts = {};

  // Рахуємо кількість кожного елемента
  for (const num of numList) {
    counts[num] = (counts[num] || 0) + 1;
  }

  // Підсумовуємо лише ті, які трапляються лише один раз
  return numList
    .filter((num) => counts[num] === 1)
    .reduce((sum, num) => sum + num, 0);
}

// Цікаві варіанти з Codewars
function sumNoDuplicates__(numList) {
  return numList.reduce(
    (a, b) => (numList.indexOf(b) === numList.lastIndexOf(b) ? a + b : a),
    0
  );
}
// ================================================================================================
// ================================================================================================
//*-Task №709 Return a string's even characters. (7kyu)
/*
Напишіть функцію, яка повертає послідовність (індекс починається з 1) усіх парних символів з рядка.
Якщо рядок коротший за два символи або довший за 100 символів,
функція повинна повернути "недійсний рядок".

Наприклад:
"abcdefghijklm" --> ["b", "d", "f", "h", "j", "l"]
"a"             --> "invalid string"
*/

// Мій варіант
function evenChars(string) {
  if (string.length < 2 || string.length > 100) {
    return 'invalid string';
  }
  const result = string
    .split('')
    .slice(1)
    .filter((e, i, a) => {
      if (i % 2 === 0) {
        return e;
      }
    });
  return result;
}
// Цікаві варіанти з Codewars
function evenChars_(string) {
  return string.length < 2 || string.length > 100
    ? 'invalid string'
    : [...string].filter((_, i) => i % 2);
}
// ================================================================================================
// ================================================================================================
//*-Task №710 (7kyu)
/*
Вам задано рядок літер та масив чисел.
Числа вказують позиції літер, які потрібно видалити, по порядку, починаючи з початку масиву.
Після кожного видалення розмір рядка зменшується (порожнього місця немає).
Повертає єдину літеру, що залишилася.

Приклад:
let str = "zbk", arr = [0, 1]
    str = "bk", arr = [1]
    str = "b", arr = []
    return 'b'

Примітки
Наданий рядок ніколи не буде порожнім.
Довжина масиву завжди на одиницю менша за довжину рядка.
Усі числа є допустимими.
Можуть бути дублікати літер та цифр.
*/

// Мій варіант
function lastSurvivor(letters, coords) {
  let arr = letters.split('');
  for (let pos of coords) {
    arr.splice(pos, 1);
  }
  return arr[0];
}
// Цікаві варіанти з Codewars
function lastSurvivor_(letters, coords) {
  const arr = [...letters];
  coords.map((el, i, ar) => arr.splice(el, 1));
  return arr[0];
}
//*-Task №711 Special Number (Special Numbers Series #5)(7kyu)
/*
Число є спеціальним числом, якщо його цифри складаються лише з 0, 1, 2, 3, 4 або 5.
Враховуючи число, визначте, чи є воно спеціальним числом чи ні.

Передане число буде додатним (N > 0)
Усі одноцифрові числа в інтервалі [1:5] вважаються спеціальними числами.
*/

// Мій варіант
function specialNumber(n) {
  const specialDigits = new Set(['0', '1', '2', '3', '4', '5']);
  const digits = String(n).split('');

  for (const digit of digits) {
    if (!specialDigits.has(digit)) {
      return 'NOT!!';
    }
  }

  return 'Special!!';
}
// Цікаві варіанти з Codewars
function specialNumber_(n) {
  return /[6-9]/.test(n) ? 'NOT!!' : 'Special!!';
}

// ================================================================================================
// ================================================================================================
//*-Task №712 Array Array Array (7kyu)
/*
Вам задано початковий масив із 2 значень (x). Ви використаєте його для обчислення балу.

Якщо обидва значення в (x) є числами, бал дорівнює сумі цих двох значень.
Якщо лише одне з них є числом, бал дорівнює цьому числу.
Якщо жодне з них не є числом, поверніть «Void!».

Після того, як ви отримаєте свій бал, вам потрібно повернути масив масивів.
Кожен підмасив буде таким самим, як (x), а кількість підмасивів має дорівнювати балу.

Наприклад:
якщо (x) == ['a', 3], вам слід повернути [['a', 3], ['a', 3], ['a', 3]].
*/

// Мій варіант
function explode(x) {
  const [a, b] = [...x];
  let l = 0;
  if (typeof a !== 'number' && typeof b !== 'number') {
    return 'Void!';
  }

  if (typeof a === 'number') {
    l += a;
  }
  if (typeof b === 'number') {
    l += b;
  }
  return Array(l).fill(x);
}
// Цікаві варіанти з Codewars
function explode_(x) {
  let [a, b] = x;

  if (typeof a == 'number' && typeof b == 'number')
    return new Array(a + b).fill(x);
  else if (typeof a == 'number') return new Array(a).fill(x);
  else if (typeof b == 'number') return new Array(b).fill(x);

  return 'Void!';
}
// ================================================================================================
// ================================================================================================
//*-Task №713 Coding Meetup #11 - Higher-Order Functions Series - Find the average age (7kyu)
/*
Вам буде надано послідовність об'єктів, що представляють дані про розробників, які зареєструвалися
для участі в наступній зустрічі з програмування, яку ви організовуєте.

Враховуючи наступний вхідний масив:
var list1 = [
  { firstName: 'Maria', lastName: 'Y.', country: 'Cyprus', continent: 'Europe', age: 30, language: 'Java' },
  { firstName: 'Victoria', lastName: 'T.', country: 'Puerto Rico', continent: 'Americas', age: 70, language: 'Python' },
];
Напишіть функцію, яка повертає середній вік розробників (округлений до найближчого цілого числа).
У наведеному вище прикладі ваша функція повинна повертати 50 (число).

Примітки:
Вхідний масив завжди буде дійсним та відформатованим, як у наведеному вище прикладі.
Вік представлений числом, яке може бути будь-яким додатним цілим числом.
*/

// Мій варіант
function getAverageAge(list) {
  const ageList = list.map((e) => e.age);
  const result = ageList.reduce((sum, age) => sum + age, 0) / ageList.length;
  return Math.round(result);
}
// Цікаві варіанти з Codewars
function getAverageAge_(list) {
  return Math.round(list.reduce((sum, obj) => sum + obj.age, 0) / list.length);
}
// ================================================================================================
// ================================================================================================
//*-Task №714 Minimum Steps (Array Series #6) (7kyu)
/*
Дано масив із N цілих чисел. Вам потрібно знайти, скільки разів потрібно додавати найменші числа
в масиві, поки їхня сума не стане більшою або рівною K.

Примітки:
Розмір списку — щонайменше 3.
Усі числа будуть додатними.
Числа можуть зустрічатися більше одного разу (можуть існувати дублікати).
Поріг K завжди буде досяжним.

minimumSteps({1, 10, 12, 9, 2, 3}, 6)  ==>  return (2)
Пояснення:
Ми додаємо два найменші елементи (1 + 2), їхня сума дорівнює 3.
Потім ми додаємо до нього наступне найменше число (3 + 3), тож сума стає 6.
Тепер результат більший або дорівнює 6, отже, вихідний результат (2), тобто для цього потрібно (2) операцій.

minimumSteps({8, 9, 4, 2}, 23) ==> return (3)
Пояснення:
Ми додаємо два найменші елементи (4 + 2), їхня сума дорівнює 6.
Потім додаємо до нього наступне найменше число (6 + 8), тож сума стає 14.
Тепер додаємо наступне найменше число (14 + 9), тож сума стає 23.
Тепер результат більший або дорівнює 23, отже, вихід (3), тобто для цього потрібно (3) операцій.
*/

// Мій варіант
function minimumSteps(numbers, value) {
  let steps = 0;
  numbers.sort((a, b) => a - b);
  let sum = numbers[0];
  for (let i = 1; i < numbers.length; i++) {
    if (sum < value) {
      sum += numbers[i];
      steps++;
    }
  }
  return steps;
}
// Цікаві варіанти з Codewars
function minimumSteps_(numbers, value) {
  const nums = numbers.slice().sort((a, b) => a - b);
  for (let i = 0, sum = 0; i < nums.length; i++) {
    sum += nums[i];
    if (sum >= value) {
      return i;
    }
  }
}
//
function minimumSteps__(numbers, value) {
  return numbers.sort((a, b) => a - b).filter((e, i) => (value = value - e) > 0)
    .length;
}
// ================================================================================================
// ================================================================================================
//*-Task №715 How many are smaller than me? (7kyu)
/*
Напишіть функцію, яка за заданим масивом arr повертає масив, що містить у кожному індексі i
кількість чисел, менших за arr[i] праворуч.

Наприклад:
* Input [5, 4, 3, 2, 1] => Output [4, 3, 2, 1, 0]
* Input [1, 2, 0] => Output [1, 1, 0]
*/

// Мій варіант
function smaller(nums) {
  const result = [];
  for (let i = 0; i < nums.length; i++) {
    let count = 0;
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] > nums[j]) {
        count++;
      }
    }
    result.push(count);
  }
  return result;
}
// Цікаві варіанти з Codewars
const smaller_ = (nums) =>
  nums.map((x, i) => nums.slice(i).filter((y) => x > y).length);
//
function smaller__(nums) {
  return nums.map((n, i) => {
    return nums.slice(i).filter((v) => v < n).length;
  });
}
// ================================================================================================
// ================================================================================================
//*-Task №716 Clean up after your dog (7kyu)
/*
Ви натрапили на божественну насолоду володіння собакою та садом. Тепер час зібрати все лайно! :D
Маючи двовимірний масив для зображення вашого саду, ви повинні знайти та зібрати все собаче лайно,
представлене символом '@'.

Вам також буде вказано кількість пакетів, до яких ви маєте доступ (bags), та місткість пакета (cap).
Якщо пакетів немає, то ви нічого не можете зібрати, тому можете ігнорувати cap.

Вам потрібно з'ясувати, чи достатньо у вас місткості, щоб зібрати все лайно та знову зробити
ваш сад чистим.

Якщо так, поверніть 'Clean', інакше поверніть 'Cr@p'.

Однак будьте обережні - якщо ваш собака десь на вулиці ('D'), він дуже переймається спостереженням.
Якщо він там, вам потрібно повернути 'Dog!!'.

Наприклад:
bags = 2
cap = 2
x (or garden) =
[[ _ , _ , _ , _ , _ , _ ],
 [ _ , _ , _ , _ , @ , _ ],
 [ @ , _ , _ , _ , _ , _ ]]
returns 'Clean'
*/

// Мій варіант
function crap(x, bags, cap) {
  const str = JSON.stringify(x);
  const arrD = str.match(/D/g) || [];
  const arrCrap = str.match(/@/g) || [];
  if (arrD.length > 0) {
    return 'Dog!!';
  }
  if (arrCrap.length > bags) {
    return 'Cr@p';
  }

  return 'Clean';
}
// Цікаві варіанти з Codewars
function crap_(x, bags, cap) {
  var yard = x.reduce((a, b) => a.concat(b));
  return yard.includes('D')
    ? 'Dog!!'
    : bags * cap - yard.filter((val) => val === '@').length > 0
    ? 'Clean'
    : 'Cr@p';
}
// ================================================================================================
// ================================================================================================
//*-Task №717 Head, Tail, Init and Last (7kyu)
/*
Haskell має кілька корисних функцій для роботи зі списками:
head [1,2,3,4,5] -> 1
tail [1,2,3,4,5] ->[2,3,4,5]
init [1,2,3,4,5] -> [1,2,3,4]
last [1,2,3,4,5] -> 5

Ваше завдання — реалізувати ці функції на заданій вами мові.
Переконайтеся, що масив не редагується; це може спричинити проблеми!
Ось шпаргалка:
| HEAD | <----------- TAIL ------------> |
[  1,  2,  3,  4,  5,  6,  7,  8,  9,  10]
| <----------- INIT ------------> | LAST |

head [x] = x
tail [x] = []
init [x] = []
last [x] = x

Ось як, на мою думку, ці функції будуть викликатися вашою мовою:
head([1,2,3,4,5]); => 1
tail([1,2,3,4,5]); => [2,3,4,5]
*/

// Мій варіант
function head(arr) {
  return arr[0];
}
function tail(arr) {
  return arr.slice(1);
}
function init(arr) {
  return arr.slice(0, arr.length - 1);
}
function last(arr) {
  return arr[arr.length - 1];
}

// Цікаві варіанти з Codewars
function head_(a) {
  return a[0];
}
function last_(a) {
  return a[a.length - 1];
}
function init_(a) {
  return a.slice(0, -1);
}
function tail_(a) {
  return a.slice(1);
}
// ================================================================================================
// ================================================================================================
//*-залишилось 1663шт
// console.time('timer_1');
// console.timeEnd('timer_1');
