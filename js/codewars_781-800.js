//*-Task №781 Even or Odd - Which is Greater? (7kyu)
/*
Дано рядок цифр, щоб перевірити, чи сума всіх окремих парних цифр більша за суму всіх окремих
непарних цифр. Завжди буде задано рядок чисел.

Якщо сума парних чисел більша за непарні, поверніть: "Even is greater than Odd".
Якщо сума непарних чисел більша за суму парних чисел, поверніть: "Odd is greater than Even".
Якщо сума парних і непарних чисел однакова, поверніть: "Even and Odd are the same".
 */

// Мій варіант
function evenOrOdd(str) {
  const digits = str.split('').map(Number);
  const evenSum = digits
    .filter((d) => d % 2 === 0)
    .reduce((sum, d) => sum + d, 0);
  const oddSum = digits
    .filter((d) => d % 2 !== 0)
    .reduce((sum, d) => sum + d, 0);

  if (evenSum > oddSum) return 'Even is greater than Odd';
  if (oddSum > evenSum) return 'Odd is greater than Even';
  return 'Even and Odd are the same';
}
// Цікаві варіанти з Codewars
function evenOrOdd_(str) {
  const diff = [...str]
    .map(Number)
    .reduce((a, b) => (b % 2 ? a - b : a + b), 0);

  if (diff > 0) return 'Even is greater than Odd';

  if (diff < 0) return 'Odd is greater than Even';

  return 'Even and Odd are the same';
}
// ================================================================================================
// ================================================================================================
//*-Task №782 Frequency sequence (7kyu)
/*
Ваше завдання — повернути вихідний рядок, який перетворює вхідний рядок s, замінюючи кожен символ
у s числом, що представляє кількість разів, коли цей символ зустрічається в s,
та розділяючи кожне число символом(ами) sep.
"hello world", "-" --> "1-1-3-3-2-1-1-2-1-3-1"
"19999999"   , ":" --> "1:7:7:7:7:7:7:7"
"^^^**$"     , "x" --> "3x3x3x2x2x1"
 */

// Мій варіант
function freqSeq(str, sep) {
  const frequency = {};

  for (let char of str) {
    frequency[char] = (frequency[char] || 0) + 1;
  }

  const result = [];
  for (let char of str) {
    result.push(frequency[char]);
  }

  return result.join(sep);
}
// Цікаві варіанти з Codewars
function freqSeq_(str, sep) {
  return str
    .split('')
    .map((v, i, arr) => arr.filter((vi) => vi === v).length)
    .join(sep);
}
// ================================================================================================
// ================================================================================================
//*-Task №783 Powers of i (7kyu)
/*
i — уявна одиниця, вона визначається як
i²=−1
i²=−1, отже, це розв'язок задачі
x²+1=0
x²+1=0.

Ваше завдання
Заповніть функцію pofi, яка повертає i
i у степені заданого невід'ємного цілого числа в найпростішій формі,
як рядок (відповідь може містити i).
 */

// Мій варіант
function pofi(n) {
  const remainder = n % 4;

  switch (remainder) {
    case 0:
      return '1';
    case 1:
      return 'i';
    case 2:
      return '-1';
    case 3:
      return '-i';
  }
}
// Цікаві варіанти з Codewars
function pofi_(n) {
  return ['1', 'i', '-1', '-i'][n % 4];
}
// ================================================================================================
// ================================================================================================
//*-Task №784 Unscrambled eggs (7kyu)
/*
Розшифруйте яйця.

У рядку, наданому вашій функції, одразу після кожної приголосної вставлено символ "egg".
Вам потрібно повернути рядок до того, як він стане яйцекодованим.

Приклад
unscrambleEggs("Beggegeggineggneggeregg")  =>  "Beginner"
//             "B---eg---in---n---er---"
 */

// Мій варіант
function unscrambleEggs(word) {
  return word.split('egg').join('');
}
// Цікаві варіанти з Codewars
function unscrambleEggs_(word) {
  return word.replace(/egg/g, '');
}
// ================================================================================================
// ================================================================================================
//*-Task №785 Plus - minus - plus - plus - ... - Count (7kyu)
/*
Порахувати, як часто змінюється знак у масиві.

результат
число від 0 до ... . Порожній масив повертає 0

приклад
const arr = [1, -3, -4, 0, 5];

/*
| елемент | кількість |
|------|-------|
| 1 | 0 |
| -3 | 1 |
| -4 | 1 |
| 0 | 2 |
| 5 | 2 |

catchSignChange(arr) == 2;
*/

// Мій варіант
function catchSignChange(arr) {
  if (arr.length === 0) return 0;

  let count = 0;

  for (let i = 1; i < arr.length; i++) {
    const current = arr[i];
    const previous = arr[i - 1];

    // Перевіряємо зміну знаку, враховуючи нуль
    if ((previous >= 0 && current < 0) || (previous < 0 && current >= 0)) {
      count++;
    }
  }

  return count;
}
// Цікаві варіанти з Codewars
function catchSignChange_(arr) {
  return arr.slice(1).filter((e, i) => e < 0 !== arr[i] < 0).length;
}
// ================================================================================================
// ================================================================================================
//*-Task №786 Extending JavaScript Objects: Get First & Last Array Element (7kyu)
/*
Ваше завдання — розширити об'єкт JavaScript Array методами .first() та .last(), щоб отримати перший
та останній елемент масиву.

var a = [2, 5, 7, 3 ,4];

a.first(); // 2
a.last(); // 4
Примітки
У випадку порожнього масиву, методи повинні повертати undefined.
Методи не повинні змінювати свої вхідні дані.
*/

// Мій варіант
Array.prototype.first = function () {
  if (this.length === 0) {
    return undefined;
  }
  return this[0];
};
Array.prototype.last = function () {
  if (this.length === 0) {
    return undefined;
  }
  return this[this.length - 1];
};
// Цікаві варіанти з Codewars
Object.assign(Array.prototype, {
  first() {
    return this[0];
  },
  last() {
    return this[this.length - 1];
  },
});
// ================================================================================================
// ================================================================================================
//*-Task №787 Most sales (7kyu)
/*
Ви працюєте в найкращій корпорації споживчої електроніки, і ваш начальник хоче з'ясувати, які три
продукти приносять найбільший дохід. Дано 3 списки однакової довжини, як-от ці:

продукти: ["Комп'ютер", "Мобільні телефони", "Пилосос"]
кількість: [3, 24, 8]
ціни: [199, 299, 399]
Поверніть три назви продуктів з найвищим доходом (кількість * ціна) у порядку спадання
(від найвищого до найнижчого доходу).

Примітка: якщо кілька продуктів мають однаковий дохід, упорядкуйте їх відповідно до їх початкових
позицій у вхідному списку.
*/

// Мій варіант
function top3(products, amounts, prices) {
  // Створюємо масив об'єктів з інформацією про продукти
  const productData = products.map((product, index) => {
    const revenue = amounts[index] * prices[index];
    return {
      name: product,
      revenue: revenue,
      originalIndex: index, // Зберігаємо початкову позицію для випадку однакового доходу
    };
  });

  // Сортуємо продукти за доходом (спадання), а при однаковому доході - за початковою позицією
  productData.sort((a, b) => {
    if (b.revenue !== a.revenue) {
      return b.revenue - a.revenue; // Сортування за доходом (спадання)
    }
    return a.originalIndex - b.originalIndex; // При однаковому доході - за початковою позицією
  });

  // Беремо топ-3 продукти і повертаємо тільки назви
  return productData.slice(0, 3).map((item) => item.name);
}
// Цікаві варіанти з Codewars
const top3_ = (products, amounts, prices) =>
  products
    .map((name, index) => ({
      name,
      index,
      revenue: amounts[index] * prices[index],
    }))
    .sort((a, b) => b.revenue - a.revenue || a.index - b.index)
    .slice(0, 3)
    .map((product) => product.name);
// ================================================================================================
// ================================================================================================
//*-Task №788 Maxed Out (7kyu)
/*
Для цього завдання вам буде надано масив чисел, кожне число по черзі потрібно звести в куб,
і після того, як усі числа будуть зведені в куб, їх потрібно додати, щоб отримати кінцеву суму.

Якщо кінцева сума менша або дорівнює максимальному значенню, дозволеному для цілого числа,
поверніть суму, інакше поверніть "You've pushed me to the max!".

Ви можете припустити, що отримаєте коректний масив чисел.
*/

// Мій варіант
function maxedOut(arr) {
  const sum = arr.reduce((sum, elem) => {
    return sum + Math.pow(elem, 3);
  }, 0);
  return sum <= Number.MAX_SAFE_INTEGER ? sum : "You've pushed me to the max!";
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №789 Simple string reversal (7kyu)
/*
У цьому ката ми збираємося перевернути рядок, зберігаючи пробіли (якщо такі є) на їхньому
початковому місці.

Наприклад:

"our code" => "edo cruo"
-- Звичайне перевернення без пробілів - це "edocruo".

-- Однак, є пробіл на індексі 3, тому рядок стає "edo cruo"

"your code rocks" => "skco redo cruoy".

"codewars" => "srawedoc"
Більше прикладів у тестових випадках. Усі введені дані будуть малими літерами, а в деяких
випадках - пробілами.
*/

// Мій варіант
function solve(str) {
  // Отримуємо перевернутий рядок без пробілів
  const reversedChars = str.replace(/\s/g, '').split('').reverse();

  const result = [];
  let reversedIndex = 0;

  // Проходимо по оригінальному рядку
  for (let i = 0; i < str.length; i++) {
    if (str[i] === ' ') {
      result[i] = ' ';
    } else {
      result[i] = reversedChars[reversedIndex++];
    }
  }

  return result.join('');
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №790 Enumerable Magic #5- True for Just One? (7kyu)
/*
Створіть функцію з назвою one, яка приймає два параметри:

-послідовність
-функцію
і повертає true лише тоді, коли функція в параметрах повертає true рівно для одного (1) елемента
послідовності.

Приклад
one([1, 3, 5, 6, 99, 1, 3], bigger_than_ten) -> true
one([1, 3, 5, 6, 99, 88, 3], bigger_than_ten) -> false
one([1, 3, 5, 6, 5, 1, 3], bigger_than_ten) -> false
*/

// Мій варіант
function one(arr, fun) {
  let count = 0;

  for (let element of arr) {
    if (fun(element)) {
      count++;
      // Якщо знайдено більше одного елемента, що задовольняє умову,
      // можна припинити виконання раніше
      if (count > 1) {
        return false;
      }
    }
  }

  return count === 1;
}
// Цікаві варіанти з Codewars
function one_(arr, fun) {
  return arr.filter(fun).length === 1;
}
// ================================================================================================
// ================================================================================================
//*-Task №791 Find Screen Size (7kyu)
/*
Сирний Чізмен щойно отримав новий монітор! Він ним задоволений, але щойно виявив, що його старі
шпалери для робочого столу більше не підходять. Він хоче знайти нові шпалери, але не знає, якого
розміру шпалери йому шукати, і, на жаль, він щойно викинув коробку від нового монітора.
На щастя, він пам'ятає ширину та співвідношення сторін монітора з того часу, як Боб Мортімер
продав його йому. Чи можете ви допомогти Сиренку?

Завдання
Враховуючи ціле число ширини та співвідношення сторін рядка, записане як ШИРИНА:ВИСОТА,
виведіть розміри екрана як рядок, записаний як ШИРИНАxВИСОТА.

Примітка: Розрахована висота має бути представлена ​​як ціле число. Якщо висота дробова, обріжте її.
*/

// Мій варіант
function findScreenHeight(width, ratio) {
  // Розділяємо співвідношення сторін на ширину та висоту
  const [ratioWidth, ratioHeight] = ratio.split(':').map(Number);

  // Обчислюємо висоту: (ширина * висота_співвідношення) / ширина_співвідношення
  const height = Math.floor((width * ratioHeight) / ratioWidth);

  // Повертаємо результат у форматі "ШИРИНАxВИСОТА"
  return `${width}x${height}`;
}

// Цікаві варіанти з Codewars
function findScreenHeight_(width, ratio) {
  const [widthRatio, heightRatio] = ratio.split(':');
  const height = (width / widthRatio) * heightRatio;
  return width + 'x' + height;
}
// ================================================================================================
// ================================================================================================
//*-Task №792 Boolean logic from scratch (7kyu)
/*
Завдання
Вам потрібно реалізувати дві функції, xor та or, які відтворюють поведінку відповідних операторів:

xor = Приймає 2 значення та повертає true тоді, і тільки тоді, коли одне з них є істинним.
or = Приймає 2 значення та повертає true, якщо будь-яке з них є істинним.
При цьому не можна використовувати оператор or: ||.

Вхідні дані
Не всі вхідні дані будуть логічними значеннями - будуть істинні та хибні значення
[останні включають також порожні рядки та порожні масиви].
Завжди буде надано 2 значення.
Приклади
xor(true, true) має повертати false
xor(false, true) має повертати true
or(true, false) має повертати true
or(false, false) має повертати true
*/

// Мій варіант
function xor(a, b) {
  return Boolean(a) !== Boolean(b);
}

function or(a, b) {
  return Boolean(a) ? true : Boolean(b);
}
// Цікаві варіанти з Codewars
const or_ = (a, b) => (a ? true : !!b);
const xor_ = (a, b) => (a ? !b : !!b);
//
const or__ = (a, b) => {
  if (a) {
    return true;
  }
  if (b) {
    return true;
  }
  return false;
};

const xor__ = (a, b) => {
  if (a && !b) {
    return true;
  }
  if (b && !a) {
    return true;
  }
  return false;
};
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
