//*-Task №781 Even or Odd - Which is Greater? (7kyu)
/*
Дано рядок цифр, щоб перевірити, чи сума всіх окремих парних цифр більша за суму всіх окремих
непарних цифр. Завжди буде задано рядок чисел.

Якщо сума парних чисел більша за непарні, поверніть: "Even is greater than Odd".
Якщо сума непарних чисел більша за суму парних чисел, поверніть: "Odd is greater than Even".
Якщо сума парних і непарних чисел однакова, поверніть: "Even and Odd are the same".
 */

// Мій варіант
function evenOrOdd(str) {
  const digits = str.split('').map(Number);
  const evenSum = digits
    .filter((d) => d % 2 === 0)
    .reduce((sum, d) => sum + d, 0);
  const oddSum = digits
    .filter((d) => d % 2 !== 0)
    .reduce((sum, d) => sum + d, 0);

  if (evenSum > oddSum) return 'Even is greater than Odd';
  if (oddSum > evenSum) return 'Odd is greater than Even';
  return 'Even and Odd are the same';
}
// Цікаві варіанти з Codewars
function evenOrOdd_(str) {
  const diff = [...str]
    .map(Number)
    .reduce((a, b) => (b % 2 ? a - b : a + b), 0);

  if (diff > 0) return 'Even is greater than Odd';

  if (diff < 0) return 'Odd is greater than Even';

  return 'Even and Odd are the same';
}
// ================================================================================================
// ================================================================================================
//*-Task №782 Frequency sequence (7kyu)
/*
Ваше завдання — повернути вихідний рядок, який перетворює вхідний рядок s, замінюючи кожен символ
у s числом, що представляє кількість разів, коли цей символ зустрічається в s,
та розділяючи кожне число символом(ами) sep.
"hello world", "-" --> "1-1-3-3-2-1-1-2-1-3-1"
"19999999"   , ":" --> "1:7:7:7:7:7:7:7"
"^^^**$"     , "x" --> "3x3x3x2x2x1"
 */

// Мій варіант
function freqSeq(str, sep) {
  const frequency = {};

  for (let char of str) {
    frequency[char] = (frequency[char] || 0) + 1;
  }

  const result = [];
  for (let char of str) {
    result.push(frequency[char]);
  }

  return result.join(sep);
}
// Цікаві варіанти з Codewars
function freqSeq_(str, sep) {
  return str
    .split('')
    .map((v, i, arr) => arr.filter((vi) => vi === v).length)
    .join(sep);
}
// ================================================================================================
// ================================================================================================
//*-Task №783 Powers of i (7kyu)
/*
i — уявна одиниця, вона визначається як
i²=−1
i²=−1, отже, це розв'язок задачі
x²+1=0
x²+1=0.

Ваше завдання
Заповніть функцію pofi, яка повертає i
i у степені заданого невід'ємного цілого числа в найпростішій формі,
як рядок (відповідь може містити i).
 */

// Мій варіант
function pofi(n) {
  const remainder = n % 4;

  switch (remainder) {
    case 0:
      return '1';
    case 1:
      return 'i';
    case 2:
      return '-1';
    case 3:
      return '-i';
  }
}
// Цікаві варіанти з Codewars
function pofi_(n) {
  return ['1', 'i', '-1', '-i'][n % 4];
}
// ================================================================================================
// ================================================================================================
//*-Task №784 Unscrambled eggs (7kyu)
/*
Розшифруйте яйця.

У рядку, наданому вашій функції, одразу після кожної приголосної вставлено символ "egg".
Вам потрібно повернути рядок до того, як він стане яйцекодованим.

Приклад
unscrambleEggs("Beggegeggineggneggeregg")  =>  "Beginner"
//             "B---eg---in---n---er---"
 */

// Мій варіант
function unscrambleEggs(word) {
  return word.split('egg').join('');
}
// Цікаві варіанти з Codewars
function unscrambleEggs_(word) {
  return word.replace(/egg/g, '');
}
// ================================================================================================
// ================================================================================================
//*-Task №785 Plus - minus - plus - plus - ... - Count (7kyu)
/*
Порахувати, як часто змінюється знак у масиві.

результат
число від 0 до ... . Порожній масив повертає 0

приклад
const arr = [1, -3, -4, 0, 5];

/*
| елемент | кількість |
|------|-------|
| 1 | 0 |
| -3 | 1 |
| -4 | 1 |
| 0 | 2 |
| 5 | 2 |

catchSignChange(arr) == 2;
*/

// Мій варіант
function catchSignChange(arr) {
  if (arr.length === 0) return 0;

  let count = 0;

  for (let i = 1; i < arr.length; i++) {
    const current = arr[i];
    const previous = arr[i - 1];

    // Перевіряємо зміну знаку, враховуючи нуль
    if ((previous >= 0 && current < 0) || (previous < 0 && current >= 0)) {
      count++;
    }
  }

  return count;
}
// Цікаві варіанти з Codewars
function catchSignChange_(arr) {
  return arr.slice(1).filter((e, i) => e < 0 !== arr[i] < 0).length;
}
// ================================================================================================
// ================================================================================================
//*-Task №786 Extending JavaScript Objects: Get First & Last Array Element (7kyu)
/*
Ваше завдання — розширити об'єкт JavaScript Array методами .first() та .last(), щоб отримати перший
та останній елемент масиву.

var a = [2, 5, 7, 3 ,4];

a.first(); // 2
a.last(); // 4
Примітки
У випадку порожнього масиву, методи повинні повертати undefined.
Методи не повинні змінювати свої вхідні дані.
*/

// Мій варіант
Array.prototype.first = function () {
  if (this.length === 0) {
    return undefined;
  }
  return this[0];
};
Array.prototype.last = function () {
  if (this.length === 0) {
    return undefined;
  }
  return this[this.length - 1];
};
// Цікаві варіанти з Codewars
Object.assign(Array.prototype, {
  first() {
    return this[0];
  },
  last() {
    return this[this.length - 1];
  },
});
// ================================================================================================
// ================================================================================================
//*-Task №787 Most sales (7kyu)
/*
Ви працюєте в найкращій корпорації споживчої електроніки, і ваш начальник хоче з'ясувати, які три
продукти приносять найбільший дохід. Дано 3 списки однакової довжини, як-от ці:

продукти: ["Комп'ютер", "Мобільні телефони", "Пилосос"]
кількість: [3, 24, 8]
ціни: [199, 299, 399]
Поверніть три назви продуктів з найвищим доходом (кількість * ціна) у порядку спадання
(від найвищого до найнижчого доходу).

Примітка: якщо кілька продуктів мають однаковий дохід, упорядкуйте їх відповідно до їх початкових
позицій у вхідному списку.
*/

// Мій варіант
function top3(products, amounts, prices) {
  // Створюємо масив об'єктів з інформацією про продукти
  const productData = products.map((product, index) => {
    const revenue = amounts[index] * prices[index];
    return {
      name: product,
      revenue: revenue,
      originalIndex: index, // Зберігаємо початкову позицію для випадку однакового доходу
    };
  });

  // Сортуємо продукти за доходом (спадання), а при однаковому доході - за початковою позицією
  productData.sort((a, b) => {
    if (b.revenue !== a.revenue) {
      return b.revenue - a.revenue; // Сортування за доходом (спадання)
    }
    return a.originalIndex - b.originalIndex; // При однаковому доході - за початковою позицією
  });

  // Беремо топ-3 продукти і повертаємо тільки назви
  return productData.slice(0, 3).map((item) => item.name);
}
// Цікаві варіанти з Codewars
const top3_ = (products, amounts, prices) =>
  products
    .map((name, index) => ({
      name,
      index,
      revenue: amounts[index] * prices[index],
    }))
    .sort((a, b) => b.revenue - a.revenue || a.index - b.index)
    .slice(0, 3)
    .map((product) => product.name);
// ================================================================================================
// ================================================================================================
//*-Task №788 Maxed Out (7kyu)
/*
Для цього завдання вам буде надано масив чисел, кожне число по черзі потрібно звести в куб,
і після того, як усі числа будуть зведені в куб, їх потрібно додати, щоб отримати кінцеву суму.

Якщо кінцева сума менша або дорівнює максимальному значенню, дозволеному для цілого числа,
поверніть суму, інакше поверніть "You've pushed me to the max!".

Ви можете припустити, що отримаєте коректний масив чисел.
*/

// Мій варіант
function maxedOut(arr) {
  const sum = arr.reduce((sum, elem) => {
    return sum + Math.pow(elem, 3);
  }, 0);
  return sum <= Number.MAX_SAFE_INTEGER ? sum : "You've pushed me to the max!";
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №789 Simple string reversal (7kyu)
/*
У цьому ката ми збираємося перевернути рядок, зберігаючи пробіли (якщо такі є) на їхньому
початковому місці.

Наприклад:

"our code" => "edo cruo"
-- Звичайне перевернення без пробілів - це "edocruo".

-- Однак, є пробіл на індексі 3, тому рядок стає "edo cruo"

"your code rocks" => "skco redo cruoy".

"codewars" => "srawedoc"
Більше прикладів у тестових випадках. Усі введені дані будуть малими літерами, а в деяких
випадках - пробілами.
*/

// Мій варіант
function solve(str) {
  // Отримуємо перевернутий рядок без пробілів
  const reversedChars = str.replace(/\s/g, '').split('').reverse();

  const result = [];
  let reversedIndex = 0;

  // Проходимо по оригінальному рядку
  for (let i = 0; i < str.length; i++) {
    if (str[i] === ' ') {
      result[i] = ' ';
    } else {
      result[i] = reversedChars[reversedIndex++];
    }
  }

  return result.join('');
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №790 Enumerable Magic #5- True for Just One? (7kyu)
/*
Створіть функцію з назвою one, яка приймає два параметри:

-послідовність
-функцію
і повертає true лише тоді, коли функція в параметрах повертає true рівно для одного (1) елемента
послідовності.

Приклад
one([1, 3, 5, 6, 99, 1, 3], bigger_than_ten) -> true
one([1, 3, 5, 6, 99, 88, 3], bigger_than_ten) -> false
one([1, 3, 5, 6, 5, 1, 3], bigger_than_ten) -> false
*/

// Мій варіант
function one(arr, fun) {
  let count = 0;

  for (let element of arr) {
    if (fun(element)) {
      count++;
      // Якщо знайдено більше одного елемента, що задовольняє умову,
      // можна припинити виконання раніше
      if (count > 1) {
        return false;
      }
    }
  }

  return count === 1;
}
// Цікаві варіанти з Codewars
function one_(arr, fun) {
  return arr.filter(fun).length === 1;
}
// ================================================================================================
// ================================================================================================
//*-Task №791 Find Screen Size (7kyu)
/*
Сирний Чізмен щойно отримав новий монітор! Він ним задоволений, але щойно виявив, що його старі
шпалери для робочого столу більше не підходять. Він хоче знайти нові шпалери, але не знає, якого
розміру шпалери йому шукати, і, на жаль, він щойно викинув коробку від нового монітора.
На щастя, він пам'ятає ширину та співвідношення сторін монітора з того часу, як Боб Мортімер
продав його йому. Чи можете ви допомогти Сиренку?

Завдання
Враховуючи ціле число ширини та співвідношення сторін рядка, записане як ШИРИНА:ВИСОТА,
виведіть розміри екрана як рядок, записаний як ШИРИНАxВИСОТА.

Примітка: Розрахована висота має бути представлена ​​як ціле число. Якщо висота дробова, обріжте її.
*/

// Мій варіант
function findScreenHeight(width, ratio) {
  // Розділяємо співвідношення сторін на ширину та висоту
  const [ratioWidth, ratioHeight] = ratio.split(':').map(Number);

  // Обчислюємо висоту: (ширина * висота_співвідношення) / ширина_співвідношення
  const height = Math.floor((width * ratioHeight) / ratioWidth);

  // Повертаємо результат у форматі "ШИРИНАxВИСОТА"
  return `${width}x${height}`;
}

// Цікаві варіанти з Codewars
function findScreenHeight_(width, ratio) {
  const [widthRatio, heightRatio] = ratio.split(':');
  const height = (width / widthRatio) * heightRatio;
  return width + 'x' + height;
}
// ================================================================================================
// ================================================================================================
//*-Task №792 Boolean logic from scratch (7kyu)
/*
Завдання
Вам потрібно реалізувати дві функції, xor та or, які відтворюють поведінку відповідних операторів:

xor = Приймає 2 значення та повертає true тоді, і тільки тоді, коли одне з них є істинним.
or = Приймає 2 значення та повертає true, якщо будь-яке з них є істинним.
При цьому не можна використовувати оператор or: ||.

Вхідні дані
Не всі вхідні дані будуть логічними значеннями - будуть істинні та хибні значення
[останні включають також порожні рядки та порожні масиви].
Завжди буде надано 2 значення.
Приклади
xor(true, true) має повертати false
xor(false, true) має повертати true
or(true, false) має повертати true
or(false, false) має повертати true
*/

// Мій варіант
function xor(a, b) {
  return Boolean(a) !== Boolean(b);
}

function or(a, b) {
  return Boolean(a) ? true : Boolean(b);
}
// Цікаві варіанти з Codewars
const or_ = (a, b) => (a ? true : !!b);
const xor_ = (a, b) => (a ? !b : !!b);
//
const or__ = (a, b) => {
  if (a) {
    return true;
  }
  if (b) {
    return true;
  }
  return false;
};

const xor__ = (a, b) => {
  if (a && !b) {
    return true;
  }
  if (b && !a) {
    return true;
  }
  return false;
};
// ================================================================================================
// ================================================================================================
//*-Task №793 [Code Golf] Even Check (7kyu)
/*
Створіть функцію, яка приймає число n, 1 <= n <= 1000, як параметр і повертає true, якщо число
парне, і false, якщо непарне.

Довжина вашого коду має бути менше або дорівнювати 19 символам.
Використання оператора % заборонено.
*/

// Мій варіант
evenCheck = (n) => !(n & 1); // без пробілів та ;

// Цікаві варіанти з Codewars
// ================================================================================================
// ================================================================================================
//*-Task №794 Operator overload ? (7kyu)
/*
У нас є клас з назвою 'Foo' з атрибутом 'val'.

var foo = new Foo(2); // foo.val = 2;
var boo = new Foo(3); // boo.val = 3;
Ми хочемо мати можливість підсумовувати два об'єкти Foo за допомогою оператора '+'.

foo + boo // => має повернути 5
*/

// Мій варіант
class Foo {
  constructor(val) {
    this.val = val;
  }

  valueOf() {
    return this.val;
  }
}
// Цікаві варіанти з Codewars
var Foo_ = function (value) {
  this.val = value;
};

Foo_.prototype.valueOf = function () {
  return this.val;
};
// ================================================================================================
// ================================================================================================
//*-Task №795 Wordsearch (7kyu)
/*
Створіть функцію wordSearch(word,text), яка шукає, чи присутнє слово word у заданій текстовій змінній.

Зверніть увагу, що це має бути повне слово, тобто воно має бути оточене межею слова
(пробіли, кінець/початок рядка, різні розділові знаки тощо).

Example:
Text - "what makes the desert beautiful, said the little prince is that somewhere it hides a well";

wordSearch("prince",text)--> true
wordSearch("beautiful",text)--> true
wordSearch("clown",text)--> false
wordSearch("yellow",text)--> false
wordSearch("akes the",text)--> false
*/

// Мій варіант
function wordSearch(word, text) {
  return text
    .toLowerCase()
    .split(/\W+/) // розбиває текст по будь-яких неалфавітних символах (пробіли, коми, крапки тощо).
    .some((w) => w === word.toLowerCase());
}
// Цікаві варіанти з Codewars
function wordsearch_(n) {
  return text.search('\\b' + n + '\\b') > -1;
}
// ================================================================================================
// ================================================================================================
//*-Task №796 Fast Fibonacci (7kyu)
/*
Швидке обчислення Фібоначчі
Загальна реалізація алгоритму Фібоначчі зазвичай виглядає приблизно так:
function fib(num) {
if (num < 2) return num;
return fib(num - 1) + fib(num - 2);
}
Це все, і добре, але ця функція не дуже ефективна.
Якби я хотів отримати 1000-те число в ряду, мені довелося б чекати... днями? можливо, роками?

Ваше завдання
Напишіть ефективнішу функцію Фібоначчі, яка може обчислювати 1000+ числовий ряд без зайвих зусиль.
Ознайомтеся з оптимізацією хвостових викликів для отримання допомоги.

Початкові значення
fib(0) = 0;
fib(1) = 1;
*/

// Мій варіант
function fib(n) {
  if (n < 2) return n;
  let a = 0,
    b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}
// Цікаві варіанти з Codewars
function fib_(num, current = 0, next = 1) {
  if (num === 0) return current;

  return fib(--num, next, current + next);
}
// ================================================================================================
// ================================================================================================
//*-Task №797 Counting in the Amazon (7kyu)
/*
Арара - це ізольоване плем'я, яке живе в Амазонці і рахує парами. Наприклад, один до восьми
виглядає так:

1 = anane
2 = adak
3 = adak anane
4 = adak adak
5 = adak adak anane
6 = adak adak adak
7 = adak adak adak anane
8 = adak adak adak adak
Візьміть задане число та поверніть еквівалент Арари.

напр.

3 --> "adak anane"

8 --> "adak adak adak adak"
*/

// Мій варіант
function countArara(n) {
  if (n < 1) return '';
  if (n === 1) return 'anane';
  return (
    new Array(Math.floor(n / 2)).fill('adak').join(' ') +
    (n % 2 === 0 ? '' : ' anane')
  );
}
// Цікаві варіанти з Codewars
function countArara_(n) {
  switch (n) {
    case 0:
      return '';
    case 1:
      return 'anane';
    case 2:
      return 'adak';
    default:
      return 'adak ' + countArara_(n - 2);
  }
}
// ================================================================================================
// ================================================================================================
//*-Task №798 No Loops 1 - Small enough? (7kyu)
/*
Вам буде задано масив та граничне значення. Ви повинні перевірити, чи всі значення в масиві менші
або дорівнюють граничному значенню. Якщо всі вони менші або дорівнюють граничному значенню,
поверніть значення true. В іншому випадку поверніть значення false.

Ви можете вважати, що всі значення в масиві є числами.

Не використовуйте цикли. Не змінюйте вхідний масив.
*/

// Мій варіант
function smallEnough(a, limit) {
  return a.every((n) => {
    return n <= limit;
  });
}
// Цікаві варіанти з Codewars
const smallEnough_ = (a, limit) => Math.max(...a) <= limit;
// ================================================================================================
// ================================================================================================
//*-Task №799 Nth Root of a Number (7kyu)
/*
Дано два числа x та n. Обчисліть (додатний) n-й корінь з x;
це означає, що оскільки r = результат, r^n = x

Приклади
x = 4 n = 2 --> 2 # квадратний корінь з 4 дорівнює 2 2^2 = 4
x = 8 n = 3 --> 2 # кубічний корінь з 8 дорівнює 2 2^3 = 8
x = 256 n = 4 --> 4 # четвертий корінь з 256 дорівнює 4 4^4 = 256
x = 9 n = 2 --> 3 # квадратний корінь з 9 дорівнює 3 3^2 = 9
x = 6.25 n = 2 --> 2.5 # 2.5^2 = 6.25
Примітки:
4 <= x < 10 ^ 20
4 <= n <= 50
*/

// Мій варіант
function root(x, n) {
  return x ** (1 / n);
}
// Цікаві варіанти з Codewars
function root_(x, n) {
  return Math.pow(x, 1 / n);
}
// ================================================================================================
// ================================================================================================
//*-Task №800 Add property to every object in array (7kyu)
/*
Ваше завдання — додати нову властивість usersAnswer до кожного об'єкта в масиві questions.
Значення usersAnswer має бути встановлене на null. Розв'язок має працювати для масиву будь-якої довжини.

Наприклад:
var questions = [{
    question: "What's the currency of the USA?",
    choices: ["US dollar", "Ruble", "Horses", "Gold"],
    corAnswer: 0
}, {
    question: "Where was the American Declaration of Independence signed?",
    choices: ["Philadelphia", "At the bottom", "Frankie's Pub", "China"],
    corAnswer: 0
}];

Після додавання властивості результат має бути таким:
var questions = [{
    question: "What's the currency of the USA?",
    choices: ["US dollar", "Ruble", "Horses", "Gold"],
    corAnswer: 0,
    usersAnswer: null
}, {
    question: "Where was the American Declaration of Independence signed?",
    choices: ["Philadelphia", "At the bottom", "Frankie's pub", "China"],
    corAnswer: 0,
    usersAnswer: null
}];

Масив запитань вже визначено для вас і не такий самий, як у прикладі.
*/

// Мій варіант
questions.forEach((q) => (q.usersAnswer = null));
// Цікаві варіанти з Codewars
questions_.forEach(function (i) {
  i.usersAnswer = null;
});
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
