//*-Task №641 Move 10 (5kyu)
/*
Перемістіть кожну літеру в наданому рядку на 10 літер вперед по алфавіту.
Якщо він проходить після «z», почніть знову з «a».
Введенням буде рядок довжиною > 0.
*/

// Мій варіант
function moveTen(s) {
  const shift = 10;
  const aCode = 'a'.charCodeAt(0);
  const zCode = 'z'.charCodeAt(0);
  const alphabetSize = zCode - aCode + 1;

  let result = '';

  for (let i = 0; i < s.length; i++) {
    let char = s[i];
    let charCode = char.charCodeAt(0);

    let newCharCode = charCode + shift;

    if (newCharCode > zCode) {
      newCharCode = aCode + ((newCharCode - zCode - 1) % alphabetSize);
    }

    result += String.fromCharCode(newCharCode);
  }

  return result;
}
// Цікаві варіанти з Codewars
function moveTen_(s) {
  return s
    .split('')
    .map((e) =>
      e.charCodeAt(0) + 10 > 122
        ? String.fromCharCode(e.charCodeAt(0) - 16)
        : String.fromCharCode(e.charCodeAt(0) + 10)
    )
    .join('');
}
// ================================================================================================
// ================================================================================================
//*-Task №642 Disarium Number (Special Numbers Series #3) (5kyu)
/*
Визначення
Число дизарію — це число, яке в сумі своїх цифр, поєднаних із відповідними позиціями,
дорівнює самому числу.

завдання
Знайдіть число, чи є воно Disarium чи ні.
Передане число завжди додатне.

disariumNumber(89) ==> повернути "Disarium !!"
disariumNumber(564) ==> повернути "Ні!!"
*/

// Мій варіант
function disariumNumber(n) {
  let digits = n.toString();
  let sum = 0;

  for (let i = 0; i < digits.length; i++) {
    sum += Math.pow(parseInt(digits[i]), i + 1);
  }

  return sum === n ? 'Disarium !!' : 'Not !!';
}
// Цікаві варіанти з Codewars
const disariumNumber_ = (n) =>
  `${
    n === n.toString().split``.reduce((r, e, i) => r + e ** (i + 1), 0)
      ? 'Disarium'
      : 'Not'
  } !!`;
// ================================================================================================
// ================================================================================================
//*-Task №643 Balanced Number (Special Numbers Series #1 ) (5kyu)
/*
Збалансоване число — це число, в якому сума цифр ліворуч від середньої цифри (цифр) і сума цифр
праворуч від середньої цифри (цифр) рівні.

Якщо число має непарну кількість цифр, то середня цифра лише одна. (Наприклад, 92645 має одну середню
цифру, 6.) В іншому випадку є дві середні цифри. (Наприклад, середніми цифрами 1301 є 3 і 0.)

Середню(і) цифру(и) не слід враховувати під час визначення того, збалансоване число чи ні, напр.
413023 є збалансованим числом, тому що ліва і права сума дорівнюють 5.

завдання
Дано число, знайдіть, чи воно збалансоване, і поверніть рядок 'Balanced' або 'Not Balanced'
відповідно. Передане число завжди буде позитивним.

7 ==> return "Balanced"
295591 ==> return "Not Balanced"
959 ==> return "Balanced"
27102983 ==> return "Not Balanced"
*/

// Мій варіант
function balancedNum(number) {
  const numbers = `${number}`.split('').map(Number);
  const len = numbers.length;

  if (len < 2) return 'Balanced';

  const mid = Math.floor(len / 2);
  const leftSum = numbers
    .slice(0, mid - (len % 2 === 0 ? 1 : 0))
    .reduce((sum, num) => sum + num, 0);
  const rightSum = numbers.slice(mid + 1).reduce((sum, num) => sum + num, 0);

  return leftSum === rightSum ? 'Balanced' : 'Not Balanced';
}

// Цікаві варіанти з Codewars
function balancedNum_(number) {
  let str = `${number}`,
    len = (str.length - (str.length % 2 ? -1 : -2)) / 2,
    sum = (digits) => [...digits].reduce((a, b) => a + +b, 0);

  return sum(str.slice(0, len)) === sum(str.slice(-len))
    ? 'Balanced'
    : 'Not Balanced';
}
// ================================================================================================
// ================================================================================================
//*-Task №644 Simple Fun #74: Growing Plant  (5kyu)
/*
завдання
Щодня рослина росте на більшу швидкість. Кожної ночі висота цієї рослини зменшується на лічильник
швидкості через брак сонячного тепла. Початкова висота рослини 0 метрів. Висаджуємо насіння на
початку дня. Ми хочемо знати, коли висота рослини досягне певного рівня.

приклад
Для upSpeed ​​= 100, downSpeed ​​= 10 і бажаної висоти = 910 вихід має бути 10.

Вхід/Вихід
[введення] ціле число upSpeed
Додатне ціле число, що представляє щоденне зростання.

Обмеження: 5 ≤ upSpeed ​​≤ 100.

[введення] ціле число downSpeed
Додатне ціле число, що представляє нічне зниження.
Обмеження: 2 ≤ downSpeed ​​< upSpeed.

[введення] ціле число бажаної висоти
Додатне ціле число, що представляє поріг.
Обмеження: 4 ≤ бажана висота ≤ 1000.

[вивести] ціле число
Кількість днів, які знадобляться, щоб рослина досягла/пройшла бажану висоту (включаючи останній день
у загальній кількості).
*/

// Мій варіант
function growingPlant(upSpeed, downSpeed, desiredHeight) {
  let currentHeight = 0;
  let days = 0;

  while (currentHeight < desiredHeight) {
    currentHeight += upSpeed;
    days++;

    if (currentHeight >= desiredHeight) {
      return days;
    }

    currentHeight -= downSpeed;
  }

  return days;
}
// Цікаві варіанти з Codewars
const growingPlant_ = (upSpeed, downSpeed, desiredHeight) =>
  desiredHeight < upSpeed
    ? 1
    : Math.ceil((desiredHeight - upSpeed) / (upSpeed - downSpeed)) + 1;
// ================================================================================================
// ================================================================================================
//*-Task №645 Sum of a Beach (5kyu)
/*
Пляжі наповнені піском, водою, рибою та сонцем. Дано рядок, обчисліть, скільки разів слова
"Sand", "Water", "Fish", and "Sun"  з’являються без накладання (незалежно від регістру).

Приклади
"WAtErSlIde"                    ==>  1
"GolDeNSanDyWateRyBeaChSuNN"    ==>  3
"gOfIshsunesunFiSh"             ==>  4
"cItYTowNcARShoW"               ==>  0
*/

// Мій варіант
function sumOfABeach(beach) {
  let regex = /sand|water|fish|sun/gi;
  let matches = beach.match(regex);
  return matches ? matches.length : 0;
}
// Цікаві варіанти з Codewars
const sumOfABeach_ = (beach) =>
  (beach.match(/sand|water|fish|sun/gi) || []).length;
// ================================================================================================
// ================================================================================================
//*-Task №645 Discover The Original Price (7kyu)
/*
Нам потрібно написати якийсь код, щоб повернути початкову ціну продукту, тип повернення має бути
десяткового типу, а число має бути округлено до двох знаків після коми.

Нам буде дана ціна продажу (ціна зі знижкою) і відсоток продажу, наша робота полягає в тому,
щоб визначити початкову ціну.

Наприклад:
Враховуючи товар за розпродажною ціною 75 доларів США після застосування знижки 25%, функція має
повернути початкову ціну цього товару до застосування відсотка розпродажу, який, звичайно, є (100,00 доларів США), округленим до двох знаків після коми.

DiscoverOriginalPrice(75, 25) => 100,00M, де 75 — ціна продажу (ціна зі знижкою), 25 — відсоток
продажу, а 100 — початкова ціна
*/

// Мій варіант
function discoverOriginalPrice(discountedPrice, salePercentage) {
  let originalPrice = discountedPrice / ((100 - salePercentage) / 100);
  return parseFloat(originalPrice.toFixed(2));
}
// Цікаві варіанти з Codewars
function discoverOriginalPrice_(discountedPrice, salePercentage) {
  return +(discountedPrice / (1 - salePercentage / 100)).toFixed(2);
}
// ================================================================================================
// ================================================================================================
//*-Task №646 Evens and Odds (7kyu)
/*
Ця ката стосується перетворення чисел у двійкове або шістнадцяткове представлення:

Якщо число парне, переведіть його в двійкову.
Якщо число непарне, переведіть його в шістнадцяткове.
Цифри будуть позитивними. Шістнадцятковий рядок має бути малим регістром.
*/

// Мій варіант
function evensAndOdds(num) {
  return num % 2 === 0 ? num.toString(2) : num.toString(16);
}
// Цікаві варіанти з Codewars
const evensAndOdds_ = (n) => n.toString(n % 2 ? 16 : 2);
// ================================================================================================
// ================================================================================================
//*-Task №647 Word values (7kyu)
/*
Дано рядок "abc" і припущення, що кожна літера в рядку має значення, яке дорівнює її позиції в
алфавіті, наш рядок матиме значення 1 + 2 + 3 = 6. Це означає, що: a = 1, b = 2, c = 3 ... z = 26.

Вам буде надано список рядків, і вашим завданням буде повернути значення рядків, як описано вище,
помножені на позицію цього рядка у списку. Для нашої мети позиція починається з 1.

["abc", "abc abc"] має повернути [6, 24] через [6 * 1, 12 * 2]. Зверніть увагу, як пробіли ігноруються.

"abc" має значення 6, тоді як "abc abc" має значення 12. Тепер значення в позиції 1 множиться на 1,
а значення в позиції 2 множиться на 2.
Введення міститиме лише малі літери та пробіли.
*/

// Мій варіант
function wordValue(arr) {
  const calculateWordValue = (str) => {
    let sum = 0;
    for (let char of str) {
      if (char !== ' ') {
        sum += char.charCodeAt(0) - 'a'.charCodeAt(0) + 1;
      }
    }
    return sum;
  };
  let results = [];
  for (let i = 0; i < arr.length; i++) {
    let value = calculateWordValue(arr[i]);
    value *= i + 1;
    results.push(value);
  }

  return results;
}
// Цікаві варіанти з Codewars
function wordValue_(a) {
  return a.map(
    (s, i) =>
      s
        .replace(/\s/g, '')
        .split('')
        .map((b) => b.charCodeAt() - 96)
        .reduce((acc, cur) => (acc += cur), 0) *
      (i + 1)
  );
}
// ================================================================================================
// ================================================================================================
//*-Task №648 Find min and max (7kyu)
/*
Реалізуйте функцію, яка повертає мінімальне та максимальне значення списку (у такому порядку).
*/

// Мій варіант
function getMinMax(arr) {
  return [Math.min(...arr), Math.max(...arr)];
}
// Цікаві варіанти з Codewars
const getMinMax_ = (arr) => [Math.min(...arr), Math.max(...arr)];
// ================================================================================================
// ================================================================================================
//*-Task №649 Length and two values. (7kyu)
/*
Дано ціле число n і два інших значення, побудуйте масив розміром n, заповнений цими двома значеннями по черзі.

Приклади
5, true, false     -->  [true, false, true, false, true]
10, "blue", "red"  -->  ["blue", "red", "blue", "red", "blue", "red", "blue", "red", "blue", "red"]
0, "one", "two"    -->  []
*/

// Мій варіант
function alternate(n, firstValue, secondValue) {
  const result = [];
  while (result.length !== n) {
    if (result.length % 2 === 0) {
      result.push(firstValue);
    } else {
      result.push(secondValue);
    }
  }
  return result;
}
// Цікаві варіанти з Codewars
function alternate_(n, firstValue, secondValue) {
  const array = [];
  for (let i = 0; i < n; i++) {
    array.push(i % 2 === 0 ? firstValue : secondValue);
  }
  return array;
}
// ================================================================================================
// ================================================================================================
//*-Task №650 Average Scores (7kyu)
/*
Створіть функцію, яка повертає середнє значення масиву чисел («оцінки»), округлене до
найближчого цілого числа. Вам заборонено використовувати будь-які цикли (включно з циклами for,
for/in, while і do/while).

Масив ніколи не буде порожнім.
*/

// Мій варіант
function average(scores) {
  const result = scores.reduce((sum, num) => (sum += num), 0);
  return Math.round(result / scores.length);
}
// Цікаві варіанти з Codewars
function average_(scores) {
  return Math.round(scores.reduce((x, y) => x + y, 0) / scores.length);
}
// ================================================================================================
// ================================================================================================
//*-Task №651 Number Of Occurrences (7kyu)
/*
Напишіть функцію, яка повертає кількість входжень елемента в масив.

Ця функція буде визначена як властивість Array за допомогою методу Object.defineProperty, який
дозволяє визначити новий метод безпосередньо на об’єкті.
arr.numberOfOccurrences(0) === 1;
arr.numberOfOccurrences(4) === 0;
arr.numberOfOccurrences(2) === 2;
arr.numberOfOccurrences(3) === 1;
*/

// Мій варіант
Array.prototype.numberOfOccurrences = function (element) {
  var counter = 0;
  for (var i = 0; i < this.length; i++) {
    if (this[i] == element) {
      counter++;
    }
  }

  return counter;
};
// Цікаві варіанти з Codewars
Array.prototype.numberOfOccurrences_ = function (search) {
  return this.filter(function (num) {
    return search === num;
  }).length;
};
// ================================================================================================
// ================================================================================================
//*-Task №652 Pure Functions (7kyu)
/*
Функція є чистою, коли:

Він завжди повертає те саме значення з однаковими аргументами (воно не оновлюється та не залежить
від змінних, що виходять за межі області видимості);
Оцінка результату не викликає побічних ефектів (мутацій...) або результату
завдання
Вам дано функцію, яка є нечистою, і ваше завдання — очистити її.
Ця функція має повертати новий масив, де кожне значення є самим собою плюс 2 рази "модифікатор",
який надається як властивість об’єкта параметрів.

приклад:
Array = 1, 2, 3
Modifier = 5

Should return = 11, 12, 13
*/

// Мій варіант
function solution(arr, options) {
  let result = [];
  for (let i = 0; i < arr.length; ++i) {
    result[i] = arr[i] + 2 * options.modifier;
  }
  return result;
}

// Цікаві варіанти з Codewars
function solution_(arr, options) {
  return arr.map((n) => n + 2 * options.modifier);
}
// ================================================================================================
// ================================================================================================
//*-Task №653 Alphabetize a list by the nth character (7kyu)
/*
Напишіть функцію, яка приймає два параметри: i) рядок (що містить список слів) і ii) ціле число (n).
Функція має впорядкувати список за алфавітом на основі n-ї літери кожного слова.

Літери слід порівнювати без урахування регістру. Якщо обидві літери однакові, упорядкуйте їх у
звичайному порядку (лексикографічно), знову ж таки, без урахування регістру.

приклад:
функція sortIt('bid, zag', 2) //=> 'zag, bid'
Довжина всіх слів у списку буде >= n. Формат буде "x, x, x".
*/
// Мій варіант
function sortIt(list, n) {
  // Розділяємо рядок на масив слів, видаляючи пробіли та розділові знаки
  let words = list.split(',').map((word) => word.trim());

  // Сортуємо масив слів за n-ю літерою, ігноруючи регістр
  words.sort((a, b) => {
    let charA = a.charAt(n - 1).toLowerCase();
    let charB = b.charAt(n - 1).toLowerCase();

    if (charA < charB) return -1;
    if (charA > charB) return 1;
    // Якщо літери рівні, сортуємо їх лексикографічно без урахування регістру
    return a.localeCompare(b, 'en', { sensitivity: 'base' });
  });

  // Повертаємо відсортований масив у вигляді рядка зі списком слів
  return words.join(', ');
}

// Приклад використання:
console.log(sortIt('bid, zag', 2)); // Виведе: "zag, bid"

// Цікаві варіанти з Codewars
const sortIt_ = (list, n) =>
  list
    .split(`, `)
    .sort(
      (a, b) =>
        a[n - 1].toLowerCase().localeCompare(b[n - 1].toLowerCase()) ||
        a.localeCompare(b)
    )
    .join(`, `);
// ================================================================================================
// ================================================================================================
//*-Task №654 Array Leaders (Array Series #3) (7kyu)
/*
Елемент є лідером, якщо він більший за суму всіх елементів праворуч від нього.
Дано масив цілих чисел. Знайти всі ЛІДЕРИ в масиві.

Примітки
Розмір масиву становить принаймні 3 .
Числа масиву будуть сумішшю позитивних, негативних і нулів
Може статися повторення чисел у масиві.
Повернений масив має зберігати початкові числа в тому самому порядку у вихідному масиві.

Приклади:
arrayLeaders ({1, 2, 3, 4, 0}) ==> повернути {4}
Пояснення:
4 більше, ніж сума всіх елементів, розташованих у його правій частині
Примітка: останній елемент 0 дорівнює правій сумі його елементів (абстрактний нуль).

arrayLeaders ({16, 17, 4, 3, 5, 2}) ==> повернути {17, 5, 2}
Пояснення:
17 більше, ніж сума всіх елементів у його правій частині
5 більше, ніж сума всіх елементів, розташованих у його правій частині
Примітка: останній елемент 2 більший за суму його правих елементів (абстрактний нуль).

arrayLeaders ({5, 2, -1}) ==> повернути {5, 2}
Пояснення:
5 більше, ніж сума всіх елементів, розташованих у його правій частині
2 більше, ніж сума всіх елементів, розташованих у його правій частині
Примітка: останній елемент -1 менший за суму його правих елементів (абстрактний нуль).

arrayLeaders ({0, -1, -29, 3, 2}) ==> повернути {0, -1, 3, 2}
Пояснення:
0 більше, ніж сума всіх елементів у його правій частині
-1 більше, ніж сума всіх елементів у його правій частині
3 більше, ніж сума всіх елементів, розташованих у його правій частині
Примітка: останній елемент 2 більший за суму його правих елементів (абстрактний нуль).
*/

// Мій варіант
function arrayLeaders(numbers) {
  let result = [];
  let sumRight = 0; // Починаємо з нуля, оскільки останній елемент порівнюється з 0

  for (let i = numbers.length - 1; i >= 0; i--) {
    if (numbers[i] > sumRight) {
      result.unshift(numbers[i]); // Додаємо елемент на початок масиву
    }
    sumRight += numbers[i]; // Оновлюємо суму правих елементів
  }

  return result;
}

// Цікаві варіанти з Codewars
var arrayLeaders_ = (numbers) => {
  return numbers.filter(
    (a, i) => numbers.slice(i + 1).reduce((sum, b) => sum + b, 0) < a
  );
};
// ================================================================================================
// ================================================================================================
//*-Task №655 "Very Even" Numbers. (7kyu)
/*
Напишіть функцію, яка повертає істину, якщо число є "дуже парним".
Якщо число складається з однієї цифри, то воно просто "Дуже парне", якщо воно саме парне.
Якщо він містить 2 або більше цифр, він вважається "Дуже парним", якщо сума його цифр є "Дуже парним".

Приклади
число = 88 => повертає false -> 8 + 8 = 16 -> 1 + 6 = 7 => 7 непарне
число = 222 => повертає істину -> 2 + 2 + 2 = 6 => 6 парне
число = 5 => повертає false
число = 841 => повертає істину -> 8 + 4 + 1 = 13 -> 1 + 3 => 4 парне
Примітка: числа завжди будуть 0 або натуральними числами!
*/

// Мій варіант
function isVeryEvenNumber(n) {
  if (n < 10) {
    return n % 2 === 0;
  }
  let sum = 0;
  while (n > 0) {
    sum += n % 10;
    n = Math.floor(n / 10);
  }
  return isVeryEvenNumber(sum);
}

// Цікаві варіанти з Codewars
function isVeryEvenNumber_(n) {
  return !n-- || (n % 9) % 2 === 1;
}
// ================================================================================================
// ================================================================================================
//*-Task №656 Building Strings From a Hash (7kyu)
/*
Завершіть рішення так, щоб воно взяло переданий об’єкт і згенерувало зрозумілий людині рядок із
його пар ключ/значення.

Формат має бути "КЛЮЧ = ЗНАЧЕННЯ". Кожна пара ключ/значення має бути розділена комою,
за винятком останньої пари.

приклад:
solution({a: 1, b: '2'}) // should return "a = 1,b = 2"
*/

// Мій варіант
function solution(pairs) {
  const kays = Object.keys(pairs);
  const values = Object.values(pairs);
  const strPairs = [];
  for (let i = 0; i < kays.length; i++) {
    strPairs.push(`${kays[i]} = ${values[i]}`);
  }
  return strPairs.join(',');
}
// Цікаві варіанти з Codewars
function solution_(pairs) {
  return Object.keys(pairs)
    .map(function (k) {
      return k + ' = ' + pairs[k];
    })
    .join(',');
}
// ================================================================================================
// ================================================================================================
//*-Task №657 Between Extremes (7kyu)
/*
Дано масив чисел, повернути різницю між найбільшим і найменшим значеннями.

Наприклад:
[23, 3, 19, 21, 16] має повернути 20 (тобто 23 - 3).
[1, 434, 555, 34, 112] має повернути 554 (тобто 555 - 1).

Масив міститиме мінімум два елементи.
Діапазон вхідних даних гарантує, що max-min не призведе до переповнення цілих чисел.
*/

// Мій варіант
function betweenExtremes(numbers) {
  return Math.max(...numbers) - Math.min(...numbers);
}
// Цікаві варіанти з Codewars
function betweenExtremes_(numbers) {
  return Math.max.apply(Math, numbers) - Math.min.apply(Math, numbers);
}
// ================================================================================================
// ================================================================================================
//*-Task №658 By 3, or not by 3? That is the question . . . (7kyu)
/*
Трюк, який я навчився в початковій школі, щоб визначити, чи ділиться число на три, полягає в тому,
щоб додати всі цілі числа в цьому числі разом і розділити отриману суму на три. Якщо від ділення
суми на три немає залишку, то вихідне число теж ділиться на три.

Дано ряд цифр у вигляді рядка, визначте, чи число, представлене рядком, ділиться на три.

приклад:
"123" -> правда
"8409" -> правда
"100853" -> false
"33333333" -> правда
"7" -> false
Намагайтеся уникати використання оператора % (по модулю).
*/

// Мій варіант
function divisibleByThree(str) {
  let sum = 0;
  for (let i = 0; i < str.length; i++) {
    sum += parseInt(str[i]);
  }
  return sum % 3 === 0;
}
// Цікаві варіанти з Codewars
function divisibleByThree_(str) {
  return [...str].reduce((s, d) => +d + s, 0) % 3 === 0;
}
// ================================================================================================
// ================================================================================================
//*-Task №659 lucky number (7kyu)
/*
Напишіть функцію, щоб визначити, чи є число щасливим чи ні.
Якщо сума всіх цифр дорівнює 0 або кратна 9, то число є щасливим.

1892376 => 1+8+9+2+3+7+6 = 36. 36 ділиться на 9, отже, число щасливе.
Функція поверне true для щасливих чисел і false для інших.
*/

// Мій варіант
function isLucky(n) {
  const number = `${n}`.split('').reduce((sum, num) => (sum += num), 0);
  return number === 0 || number % 9 === 0;
}
// Цікаві варіанти з Codewars
const isLucky_ = (n) => n % 9 === 0;
// ================================================================================================
// ================================================================================================
//*-Task №660 Is every value in the array an array? (7kyu)
/*
Чи кожне значення в масиві є масивом?
Це має перевірити лише другий розмір масиву.
Значення вкладених масивів не обов’язково мають бути масивами.
приклади:
[[1],[2]] => true
['1','2'] => false
[{1:1},{2:2}] => false
*/

// Мій варіант
const arrCheck = (value) => {
  return !value.some((elem) => !Array.isArray(elem));
};

// Цікаві варіанти з Codewars
const arrCheck_ = (a) => a.every(Array.isArray);

// ================================================================================================
// ================================================================================================
//*-залишилось 1722шт
// console.time('timer_1');
// console.timeEnd('timer_1');
