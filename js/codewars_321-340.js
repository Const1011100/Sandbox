//*-Task №321 Count the number of cubes with paint on (8kyu)
/*
Прийшовши на співбесіду, вам пред’являють суцільний синій куб. Потім куб занурюють у червону фарбу,
покриваючи всю поверхню куба. Потім інтерв'юер продовжує розрізати куб у всіх трьох вимірах певну
кількість разів.
Ваша функція приймає як параметр кількість розрізів куба. Ви повинні повернути кількість менших кубиків,
утворених розрізами, які мають принаймні одну червону грань.
Щоб було зрозуміліше, на малюнку нижче показано куб після (зліва направо) 0, 1 і 2 розрізів.
Якщо ми розріжемо куб 2 рази, функція має повернути 26
Якщо ми розріжемо куб 4 рази, функція має повернути 98
*/

// Мій варіант
function countSquares (cuts) {
    if (cuts === 0) {
        return 1
    }
    let innerCube = Math.pow(cuts - 1, 3)
    let outerCube = Math.pow(cuts + 1, 3)
    return outerCube - innerCube
}
// Цікаві варіанти з Codewars
const countSquares_ = cuts => cuts === 0 ? 1 : (6 * cuts * cuts) + 2;
// ================================================================================================
// ================================================================================================
//*-Task №322 Take an Arrow to the knee, Functionally (8kyu)
/*
Вам буде надано масив чисел, які можна використовувати за допомогою методу String.fromCharCode() (JS),
для перетворення числа на символ. Рекомендується відобразити масив чисел і перетворити кожне число на
відповідний символ ASCII.

Приклади
Це приклад того, як перетворити число на символ ASCII:
Javascript => String.fromCharCode(97) // a
*/

// Мій варіант
const ArrowFunc = function (arr) {
    return String.fromCharCode(...arr);
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №323 Quadrants (8kyu)
/*
Дано точку на евклідовій площині (x і y), поверніть квадрант, у якому ця точка існує: 1, 2, 3 або 4 (ціле число).
x і y є ненульовими цілими числами, тому задана точка ніколи не лежить на осях.
(1, 2)     => 1
(3, 5)     => 1
(-10, 100) => 2
(-1, -9)   => 3
(19, -56)  => 4

Є чотири квадранти:
Перший квадрант, квадрант у верхньому правому куті, містить усі точки з позитивними X та Y
Другий квадрант, квадрант у верхньому лівому куті, містить усі точки з негативним X, але позитивним Y
Третій квадрант, квадрант унизу ліворуч, містить усі точки з від’ємними X та Y
Четвертий квадрант, квадрант у нижньому правому куті, містить усі точки з позитивним X, але негативним Y
*/

// Мій варіант
function quadrant(x, y) {
    if (x > 0 && y > 0) {
        return 1;
    } else if (x < 0 && y > 0) {
        return 2;
    } else if (x < 0 && y < 0) {
        return 3;
    } else {
        return 4;
    }
}
// Цікаві варіанти з Codewars
function quadrant_(x, y) {
    if (x > 0 && y > 0) return 1;
    if (x < 0 && y > 0) return 2;
    if (x < 0 && y < 0) return 3;
    return 4;
}
// ================================================================================================
// ================================================================================================
//*-Task №324 Age Range Compatibility Equation (8kyu)
/*
Усі знають класичне правило побачень «половина твого віку плюс сім», якого дотримується багато людей (включаючи мене).
Це «рекомендований» віковий діапазон для зустрічей.
Завдання
Дано ціле число (1 <= n <= 100), що представляє вік людини, поверніть її мінімальний і максимальний віковий діапазон.
Це рівняння не працює, якщо вік <= 14 років, тому замість цього використовуйте це рівняння:
min = age - 0.10 * age
max = age + 0.10 * age
Ви повинні розбити всі ваші відповіді так, щоб замість числа з плаваючою точкою вводилося ціле число
(яке не означає вік). Поверніть свою відповідь у формі [min]-[max]
age = 27   =>   20-40
age = 5    =>   4-5
age = 17   =>   15-20
*/

// Мій варіант
function datingRange(age) {
    let min, max;
    if (age <= 14) {
        min = Math.floor(age - 0.10 * age);
        max = Math.floor(age + 0.10 * age);
    } else {
        min = Math.floor(age / 2 + 7);
        max = Math.floor((age - 7) * 2);
    }
    return `${min}-${max}`;
}
// Цікаві варіанти з Codewars
function datingRange_(age) {
    return `${min(age)}-${max(age)}`;

    function min(age) {
        return Math.floor(age > 14 ? (age / 2) + 7 : age - 0.10 * age);
    }

    function max(age) {
        return Math.floor(age > 14 ? (age - 7) * 2 : age + 0.10 * age);
    }
}
// ================================================================================================
// ================================================================================================
//*-Task №325 Training JS #16: Methods of String object--slice(), substring() and substr() (8kyu)
/*
Кодування у функції cutIt, функція приймає 1 параметр: arr. arr — масив рядків.
Перша місія: проходження об’їзду, пошук найкоротшої довжини струни.
Друга місія: Знову обхід arr, перехопити всі рядки до найкоротшої довжини рядка (Почати з індексу0).
ви можете використовувати один із slice() substring() або substr().
повернення результату після завершення роботи.
cutIt(["ab","cde","fgh"]) should return ["ab","cd","fg"]
cutIt(["abc","defgh","ijklmn"]) should return ["abc","def","ijk"]
cutIt(["codewars","javascript","java"]) should return ["code","java","java"]
*/

// Мій варіант
function cutIt(arr) {
    const length = arr.map(el => { return el.length })
        .sort((a, b) => { return a - b });
    return arr.map(el => {
        return el.slice(0, length[0]);
    });
}
// Цікаві варіанти з Codewars
function cutIt_(arr) {
    const minLength = Math.min(...arr.map(x => x.length));
    return arr.map(x => x.slice(0, minLength));
}
// ================================================================================================
// ================================================================================================
//*-Task №326 Safen User Input Part I - htmlspecialchars (8kyu)
/*
Введення користувача Safen Частина I - htmlspecialchars
Ви початківець/середній/досвідчений/професіонал/всесвітньо відомий веб-розробник (виберіть один),
який володіє (n) простим/чистим/витонченим/гарним/складним/професійним/діловим веб-сайтом (виберіть один або кілька),
який містить поля форми, щоб відвідувачі могли легко надсилати електронні листи або залишати коментарі
на вашому веб-сайті. Однак з легкістю приходить небезпека. Час від часу хакер відвідує ваш веб-сайт і
намагається скомпрометувати його за допомогою XSS (Cross Site Scripting).
Це робиться шляхом введення тегів сценарію на веб-сайт через поля форми, які можуть містити шкідливий
код (наприклад, переспрямування на шкідливий веб-сайт, який викрадає особисту інформацію).
Місія
Ваша місія полягає в тому, щоб реалізувати функцію, яка перетворює такі потенційно шкідливі символи:
< --> &lt;
> --> &gt;
" --> &quot;
& --> &amp;
*/

// Мій варіант
function htmlspecialchars(formData) {
    const data = {
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
    };
    let result = formData.replace(/&/g, '&amp;');
    for (symbol in data) {
        let regExp = new RegExp(`${symbol}`, 'g');
        result = result.replace(regExp, `${data[symbol]}`);
    }
    return result;
}
// Цікаві варіанти з Codewars
function htmlspecialchars_(formData) {
    return formData.replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
}
//
function htmlspecialchars__(formData) {
    const dict = {
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '&': '&amp;',
    };
    return formData.replace(/[<>"&]/g, char => dict[char]);
}
// ================================================================================================
// ================================================================================================
//*-залишилось 56шт
// console.time('timer_1');
// console.timeEnd('timer_1');