//*-Task №301 Be Concise I - The Ternary Operator (8kyu)
/*
Будьте лаконічними. Я – тернарний оператор
Вам надається функція describeAge / describe_age, яка приймає параметр age
(який завжди буде додатним цілим числом) і виконує наступне:

Якщо вік 12 або менше, повертається "You're a(n) kid"
Якщо вік — від 13 до 17 (включно), повертається «Ти підліток»
Якщо вік становить від 18 до 64 (включно), повертається "Ви дорослий"
Якщо вік становить 65 або більше, повертається "Ви літня людина"
Ваше завдання максимально скоротити код. Зауважте, що надіслати вказаний код не спрацює,
оскільки існує обмеження на 137 символів.
*/

// Мій варіант
const describeAge = age => `You're a(n) ${age <= 12 ? 'kid' : age <= 17 ? 'teenager' : age <= 64 ? 'adult' : 'elderly'}`;
// Цікаві варіанти з Codewars
function describeAge_(age) {
    return "You're a(n) " + (age < 13 ? "kid" : age < 18 ? "teenager" : age < 65 ? "adult" : "elderly")
}
// ================================================================================================
// ================================================================================================
//*-Task №302 Enumerable Magic #2 - True for Any? (8kyu)
/*
Створити будь-який? (JS: any) функція, яка приймає масив і блок (JS: function) і повертає true,
якщо блок (/function) повертає true для будь-якого елемента в масиві. Якщо масив порожній,
функція має повернути false.
*/

// Мій варіант
function any(arr, fun) {
    return arr.length > 0 ? arr.some(item => fun(item)) : false;
}
// Цікаві варіанти з Codewars
function any_(arr, fun) {
    return arr.some(fun)
}
// ================================================================================================
// ================================================================================================
//*-Task №303 Playing with cubes II  (8kyu)
/*
Привіт Codewarrior!

Ви вже реалізували клас Cube, але тепер нам знову потрібна ваша допомога! Я про конструктори.
У нас такого немає. Давайте закодуємо два: один приймає ціле число, а другий не обробляє жодних аргументів!
Також ми маємо проблему з від’ємними значеннями. Виправте код, щоб від'ємні значення були замінені на додатні!
Конструктор, який не приймає аргументів, повинен призначити 0 властивості Side куба.
*/

// Мій варіант
class Cube {
    constructor(side = 0) {
        this.setSide(side);
    }

    getSide() {
        return this.side;
    }

    setSide(n) {
        this.side = Math.abs(n);
    }
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №304 Not so black box (8kyu)
/*
У ката попередньо завантажено функцію під назвою blackBox. З’ясуйте, що робить функція. 
Можливо, вам доведеться подумати збоку!
*/

// Мій варіант
//console.log(blackBox.toString());
//JSopenSesame();
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №305 Wilson primes (8kyu)
/*
Прості числа Вільсона задовольняють наступну умову. Нехай P представляє просте число.
Потім, ((P-1)! + 1) / (P * P)
має давати ціле число.
Ваше завдання — створити функцію, яка повертає істину, якщо дане число є простим числом Вільсона.
*/

// Мій варіант
function amIWilson(p) {
    p = BigInt(p);
    const fac = n => n ? n * fac(n - 1n) : 1n;
    const d = (fac(p - 1n) + 1n);
    return !(d % (p * p));
}
// Цікаві варіанти з Codewars
const amIWilson_ = p => [5, 13, 563].indexOf(p) > -1;
// ================================================================================================
// ================================================================================================
//*-Task №306 Do something "n.times" (Simplifying "for" loops) (8kyu)
/*
На випадок, якщо ви заблукали, ось що вам потрібно зробити: визначте метод Number.prototype.times,
який приймає функцію f як аргумент і виконує її стільки разів, скільки цілих чисел вона викликає
(наприклад, (100).times виконував би щось 100 разів). Змінна ітерації i має надаватися анонімній
функції, яка виконується, щоб підтримувати цикл через елементи масиву.
*/

// Мій варіант
Number.prototype.times = function (f) {
    for (let i = 0; i < this; i++) {
        f(i);
    }
};
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №307 What's up next? (8kyu)
/*
Дано послідовність елементів і певний елемент у цій послідовності, повернути елемент відразу після
зазначеного елемента. Якщо елемент зустрічається більше одного разу в послідовності, поверніть
елемент після першого входження. Це має працювати для послідовності будь-якого типу.
Якщо елемент відсутній або нічого не слідує за ним, функція має повертати undefined.
nextItem([1, 2, 3, 4, 5, 6, 7], 3) # 4
nextItem("testing", "t") # "e"
*/

// Мій варіант
function nextItem(xs, item) {
    var found = false;
    for (var x of xs) {
      if (found) return x;
      if (x == item) found = true;
    }
    return undefined;
  }

// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №308 Count words (8kyu)
/*
Чи можете ви реалізувати функцію, яка повертатиме кількість слів у рядку?
Ви повинні переконатися, що пробіли в рядку насправді є пробілами.
Давайте розглянемо кілька прикладів:
countWords("Hello"); // returns 1 as int
countWords("Hello, World!") // returns 2
countWords("No results for search term `s`") // returns 6
countWords(" Hello") // returns 1
// ... and so on

Які тести ми зробили для вашого коду:
Функція повинна рахувати слова, а не пробіли. Ви повинні бути впевнені, що робите це правильно
Порожній рядок не містить слів.
Рядок із пробілами навколо слід обрізати.
Не пробіли (наприклад, пробіли, символи Unicode) слід розглядати як розділювачі
Ще раз переконайтеся, що слова з такими символами, як -, ', `, підраховані правильно.
*/

// Мій варіант
const countWords = str => str.split(/\s+/).filter(x => x).length;
// Цікаві варіанти з Codewars
function countWords_(str) {
    return (str.match(/[^\s]+/g) || []).length;
}
// ================================================================================================
// ================================================================================================
//*-залишилось 74шт
// console.time('timer_1');
// console.timeEnd('timer_1');