//*-Task №301 Be Concise I - The Ternary Operator (8kyu)
/*
Будьте лаконічними. Я – тернарний оператор
Вам надається функція describeAge / describe_age, яка приймає параметр age
(який завжди буде додатним цілим числом) і виконує наступне:

Якщо вік 12 або менше, повертається "You're a(n) kid"
Якщо вік — від 13 до 17 (включно), повертається «Ти підліток»
Якщо вік становить від 18 до 64 (включно), повертається "Ви дорослий"
Якщо вік становить 65 або більше, повертається "Ви літня людина"
Ваше завдання максимально скоротити код. Зауважте, що надіслати вказаний код не спрацює,
оскільки існує обмеження на 137 символів.
*/

// Мій варіант
const describeAge = age => `You're a(n) ${age <= 12 ? 'kid' : age <= 17 ? 'teenager' : age <= 64 ? 'adult' : 'elderly'}`;
// Цікаві варіанти з Codewars
function describeAge_(age) {
    return "You're a(n) " + (age < 13 ? "kid" : age < 18 ? "teenager" : age < 65 ? "adult" : "elderly")
}
// ================================================================================================
// ================================================================================================
//*-Task №302 Enumerable Magic #2 - True for Any? (8kyu)
/*
Створити будь-який? (JS: any) функція, яка приймає масив і блок (JS: function) і повертає true,
якщо блок (/function) повертає true для будь-якого елемента в масиві. Якщо масив порожній,
функція має повернути false.
*/

// Мій варіант
function any(arr, fun) {
    return arr.length > 0 ? arr.some(item => fun(item)) : false;
}
// Цікаві варіанти з Codewars
function any_(arr, fun) {
    return arr.some(fun)
}
// ================================================================================================
// ================================================================================================
//*-Task №303 Playing with cubes II  (8kyu)
/*
Привіт Codewarrior!

Ви вже реалізували клас Cube, але тепер нам знову потрібна ваша допомога! Я про конструктори.
У нас такого немає. Давайте закодуємо два: один приймає ціле число, а другий не обробляє жодних аргументів!
Також ми маємо проблему з від’ємними значеннями. Виправте код, щоб від'ємні значення були замінені на додатні!
Конструктор, який не приймає аргументів, повинен призначити 0 властивості Side куба.
*/

// Мій варіант
class Cube {
    constructor(side = 0) {
        this.setSide(side);
    }

    getSide() {
        return this.side;
    }

    setSide(n) {
        this.side = Math.abs(n);
    }
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №304 Not so black box (8kyu)
/*
У ката попередньо завантажено функцію під назвою blackBox. З’ясуйте, що робить функція. 
Можливо, вам доведеться подумати збоку!
*/

// Мій варіант
//console.log(blackBox.toString());
//JSopenSesame();
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №305 Wilson primes (8kyu)
/*
Прості числа Вільсона задовольняють наступну умову. Нехай P представляє просте число.
Потім, ((P-1)! + 1) / (P * P)
має давати ціле число.
Ваше завдання — створити функцію, яка повертає істину, якщо дане число є простим числом Вільсона.
*/

// Мій варіант
function amIWilson(p) {
    p = BigInt(p);
    const fac = n => n ? n * fac(n - 1n) : 1n;
    const d = (fac(p - 1n) + 1n);
    return !(d % (p * p));
}
// Цікаві варіанти з Codewars
const amIWilson_ = p => [5, 13, 563].indexOf(p) > -1;
// ================================================================================================
// ================================================================================================
//*-Task №306 Do something "n.times" (Simplifying "for" loops) (8kyu)
/*
На випадок, якщо ви заблукали, ось що вам потрібно зробити: визначте метод Number.prototype.times,
який приймає функцію f як аргумент і виконує її стільки разів, скільки цілих чисел вона викликає
(наприклад, (100).times виконував би щось 100 разів). Змінна ітерації i має надаватися анонімній
функції, яка виконується, щоб підтримувати цикл через елементи масиву.
*/

// Мій варіант
Number.prototype.times = function (f) {
    for (let i = 0; i < this; i++) {
        f(i);
    }
};
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №307 What's up next? (8kyu)
/*
Дано послідовність елементів і певний елемент у цій послідовності, повернути елемент відразу після
зазначеного елемента. Якщо елемент зустрічається більше одного разу в послідовності, поверніть
елемент після першого входження. Це має працювати для послідовності будь-якого типу.
Якщо елемент відсутній або нічого не слідує за ним, функція має повертати undefined.
nextItem([1, 2, 3, 4, 5, 6, 7], 3) # 4
nextItem("testing", "t") # "e"
*/

// Мій варіант
function nextItem(xs, item) {
    var found = false;
    for (var x of xs) {
      if (found) return x;
      if (x == item) found = true;
    }
    return undefined;
  }

// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №308 Count words (8kyu)
/*
Чи можете ви реалізувати функцію, яка повертатиме кількість слів у рядку?
Ви повинні переконатися, що пробіли в рядку насправді є пробілами.
Давайте розглянемо кілька прикладів:
countWords("Hello"); // returns 1 as int
countWords("Hello, World!") // returns 2
countWords("No results for search term `s`") // returns 6
countWords(" Hello") // returns 1
// ... and so on

Які тести ми зробили для вашого коду:
Функція повинна рахувати слова, а не пробіли. Ви повинні бути впевнені, що робите це правильно
Порожній рядок не містить слів.
Рядок із пробілами навколо слід обрізати.
Не пробіли (наприклад, пробіли, символи Unicode) слід розглядати як розділювачі
Ще раз переконайтеся, що слова з такими символами, як -, ', `, підраховані правильно.
*/

// Мій варіант
const countWords = str => str.split(/\s+/).filter(x => x).length;
// Цікаві варіанти з Codewars
function countWords_(str) {
    return (str.match(/[^\s]+/g) || []).length;
}
// ================================================================================================
// ================================================================================================
//*-Task №309 "this" is a problem (8kyu)
/*
Ми хочемо створити функцію-конструктор «NameMe», яка приймає ім’я та прізвище як параметри.
Функція об’єднує ім’я та прізвище та зберігає значення у властивості «name».

Ми вже реалізували цю функцію, але коли ми фактично запускаємо код, властивість «name» доступна,
але «firstName» і «lastName» недоступні. Усі властивості мають бути доступними.
Ви можете знайти, що з ним не так? Також доступний тестовий пристрій
*/

// Мій варіант
function NameMe(first, last) {
    this.firstName = first;
    this.lastName = last;
    this.name = this.firstName + ' ' + this.lastName;
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №310 Be Concise III - Sum Squares (8kyu)
/*
Будь лаконічним III – Сума квадратів
Вам надається програма sumSquares, яка приймає масив як вхідні дані та повертає суму квадратів кожного
елемента в масиві.
Наприклад:
sumSquares([1,2,3,4,5]) === 55 // 1 ** 2 + 2 ** 2 + 3 ** 2 + 4 ** 2 + 5 ** 2
sumSquares([7,3,9,6,5]) === 200
sumSquares([11,13,15,18,2]) === 843

Скоротіть код так, щоб він відповідав вимогам.
Кілька порад:
Спробуйте дослідити вбудовані методи Array; вони можуть значно скоротити ваш код
*/

// Мій варіант
function sumSquares(array) {
    return array.reduce((accum, elem) => {
        return accum + elem ** 2;
    }, 0);
}
// Цікаві варіанти з Codewars
let sumSquares_ = a => a.reduce((s, x) => s + x * x, 0);
// ================================================================================================
// ================================================================================================
//*-Task №311 Is your period late? (8kyu)
/*
У цій ката ми створимо функцію, щоб перевірити, чи запізнюється менструація.
Наша функція прийматиме три параметри:
last - об'єкт Date з датою останнього періоду
сьогодні - об'єкт "Дата" з датою перевірки
cycleLength – ціле число, що представляє тривалість циклу в днях
Повертає значення true, якщо кількість днів, що минула від останнього до сьогоднішнього, перевищує cycleLength.
В іншому випадку поверніть false.
*/

// Мій варіант
function periodIsLate(last, today, cycleLength) {
    const timeDifference = today.getTime() - last.getTime();
    const daysPassed = timeDifference / (1000 * 3600 * 24);
    return daysPassed > cycleLength;
}
// Цікаві варіанти з Codewars
function periodIsLate_(last, today, cycleLength) {
    return (today - last) / 86400000 > cycleLength
}
// ================================================================================================
// ================================================================================================
//*-Task №312 Simple Fun #261: Whose Move (8kyu)
/*
Два гравці - «чорні» і «білі» грають в гру. Гра складається з кількох раундів. Якщо гравець виграє в
раунді, він повинен перейти знову під час наступного раунду. Якщо гравець програє раунд, інший гравець
переходить у наступний раунд. Враховуючи, чия була черга в попередньому раунді і чи він переміг,
визначте, чия черга в наступному раунді.
*/

// Мій варіант
function whoseMove(lastPlayer, win) {
    if (lastPlayer === 'white') { return win ? 'white' : 'black' };
    if (lastPlayer === 'black') { return win ? 'black' : 'white' };
}
// Цікаві варіанти з Codewars
function whoseMove_(lastPlayer, win) {
    return win ? lastPlayer : lastPlayer == "white" ? "black" : "white"
}
// ================================================================================================
// ================================================================================================
//*-Task №313 Logical calculator (8kyu)
/*
Маючи масив логічних значень і логічний оператор, повернути логічний результат на основі послідовного
застосування оператора до значень у масиві.
*/

// Мій варіант
function logicalCalc(array, op) {
    let result = array[0];
    for (let i = 1; i < array.length; i++) {
        if (op === "AND") {
            result = result && array[i];
        } else if (op === "OR") {
            result = result || array[i];
        } else if (op === "XOR") {
            result = result !== array[i];
        }
    }
    return result;
}
// Цікаві варіанти з Codewars
var ops = {
    'AND': (a, b) => a && b,
    'OR': (a, b) => a || b,
    'XOR': (a, b) => a !== b
}

function logicalCalc(array, op) {
    return array.reduce(ops[op]);
}
// ================================================================================================
// ================================================================================================
//*-Task №314 Return Two Highest Values in List (8kyu)
/*
У цій ката ваше завдання — повернути два різні найвищі значення в списку. Якщо є менше 2 унікальних
значень, поверніть якомога більше з них.
Результат також слід упорядкувати від найбільшого до найменшого.
[4, 10, 10, 9]  =>  [10, 9]
[1, 1, 1]  =>  [1]
[]  =>  []
*/

// Мій варіант
function twoHighest(arr) {
    if (arr.length <= 1) { return arr };

    const sortedArr = arr.sort((a, b) => { return b - a });
    const result = [sortedArr[0]];
    for(let i = 1; i < sortedArr.length; i++) {
        if(result[0] !== sortedArr[i]) {
            result.push(sortedArr[i]);
            break;
        }
    }

    return result;
}
// Цікаві варіанти з Codewars
function twoHighest_(arr) {
    return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
}
//
const twoHighest__ = a => a
    .filter((e, i) => i === a.lastIndexOf(e))
    .sort((x, y) => y - x)
    .slice(0, 2);
// ================================================================================================
// ================================================================================================
//*-залишилось 68шт
// console.time('timer_1');
// console.timeEnd('timer_1');