//*-Task №261 Pythagorean Triple (8kyu)
/*
Дано невідсортований масив із 3 натуральних чисел [ n1, n2, n3 ], визначте,
чи можна сформувати трійку Піфагора, використовуючи ці 3 цілі числа.

Трійка Піфагора складається з розташування 3 цілих чисел таким чином, що:

a2 + b2 = c2

Приклади
[5, 3, 4] : можна сформувати трійку Піфагора, використовуючи ці 3 цілі числа: 32 + 42 = 52
[3, 4, 5] : можна сформувати трійку Піфагора, використовуючи ці 3 цілі числа: 32 + 42 = 52
[13, 12, 5] : можна сформувати трійку Піфагора, використовуючи ці 3 цілі числа: 52 + 122 = 132
[100, 3, 999] : НЕможливо сформувати піфагорову трійку, використовуючи ці 3 цілих числа -
як би ви їх не розташували, ви ніколи не знайдете способу задовольнити рівняння a2 + b2 = c2

Повернуті значення
Для JavaScript: повертає true або false
*/

// Мій варіант
function isPythagoreanTriple(integers) {
    const arr = integers.sort((a, b) => a - b);
    return Math.pow(arr[0], 2) + Math.pow(arr[1], 2) === Math.pow(arr[2], 2);
}

// Цікаві варіанти з Codewars
function isPythagoreanTriple_(nums) {
    const [a, b, c] = nums.sort((a, b) => a - b)
    return a ** 2 + b ** 2 === c ** 2
}
// ================================================================================================
// ================================================================================================
//*-Task №262 Compare within margin (8kyu)
/*
Створіть функцію close_compare, яка приймає 3 параметри: a, b і необов’язкове поле.
Функція має повертати значення a менше, близько до або вище b.

Зверніть увагу на наступне:

Коли a близьке до b, поверніть 0.
Для цього завдання a вважається «близьким до» b, якщо маржа більша або дорівнює абсолютній відстані
між a і b.
Інакше...

Якщо a менше b, поверніть -1.
Якщо a більше b, повертається 1.
Якщо маржа не вказана, розглядайте її як нульову.
Припустимо: запас >= 0

Порада. У деяких мовах є спосіб зробити параметри необов’язковими.
Приклад 1
Якщо a = 3, b = 5 і margin = 3, то close_compare(a, b, margin) має повернути 0.
Це пояснюється тим, що a і b віддалені один від одного не більше ніж на 3 числа.

Приклад 2
Якщо a = 3, b = 5 і margin = 0, тоді close_compare(a, b, margin) має повернути -1.
Це тому, що відстань між a і b більша за 0, а a менша за b.
*/

// Мій варіант
function closeCompare(a, b, margin = 0) {
    if (Math.abs(a - b) <= margin) {
        return 0;
    } else if (a < b) {
        return -1;
    } else {
        return 1;
    }
}

// Цікаві варіанти з Codewars
function closeCompare_(a, b, m = 0) {
    return Math.abs(a - b) <= m ? 0 : Math.sign(a - b);
}
// ================================================================================================
// ================================================================================================
//*-Task №263 Basic subclasses - Adam and Eve (8kyu)
/*
Згідно з міфами про створення авраамічних релігій, Адам і Єва були першими людьми, які блукали Землею.
Ви повинні виконувати Божу роботу. Метод створення повинен повертати масив довжиною 2, що містить об’єкти
(що представляють Адама і Єву). Перший об’єкт у масиві має бути екземпляром класу Man.
Другий має бути екземпляром класу Woman. Обидва об’єкти мають бути підкласами Human.
Ваше завдання — реалізувати класи «Людина», «Чоловік» і «Жінка».
*/

// Мій варіант


// Цікаві варіанти з Codewars
class God {
    static create() {
        return [new Man('Adam'), new Woman('Eve')]
    }
}

class Human {
    constructor(name) {
        this.name = name;
    }
}

class Man extends Human {
    constructor(name) {
        super(name);
    }
}

class Woman extends Human {
    constructor(name) {
        super(name);
    }
}
// ================================================================================================
// ================================================================================================
//*-Task №264 Training JS #12: loop statement --for..in and for..of (8kyu)
/*
Функція giveMeFive приймає 1 параметр, obj, який є об’єктом.
Створіть масив (який ви зрештою повернете). Потім перегляньте об’єкт, перевіряючи кожен ключ і значення.
Якщо довжина ключа дорівнює 5, то натисніть ключ на свій масив.
Окремо, якщо довжина значення дорівнює 5, тоді надішліть значення у свій масив.

Наприкінці поверніть свій масив.
Ви повинні використовувати for..in у своєму коді, інакше ваше рішення може не прийняти цю ката.
*/

// Мій варіант
function giveMeFive(obj) {
    const result = [];
    for (let elem in obj) {
        if(elem.length === 5) { result.push(elem) };
        if(obj[elem].length === 5) { result.push(obj[elem]) };
    }
    return result;
}

// Цікаві варіанти з Codewars
const giveMeFive_ = obj =>
    Object              // converting instead for ( in )
        .entries(obj)
        .join(',')
        .split(',')
        .filter(i => i.length == 5);

// ================================================================================================
// ================================================================================================
//*-Task №265 Pirates!! Are the Cannons ready!?? (8kyu)
/*
Привіт, Матей!
Ласкаво просимо до семи морів.
Ви капітан піратського корабля.
Ви в битві проти королівського флоту.
У вас напоготові гармати... чи не так?
Ваше завдання перевірити, чи заряджені та готові артилеристи, чи вони: Вогонь!
Якщо вони не готові: Shiver me timbers!
Ваші стрільці для кожного тесту 2, 3 або 4.
Коли ви перевіряєте, чи вони готові, їх відповіді зберігаються в словнику та будуть такими: так або ні
Стріляти з меншою кількістю готових стрільців є неоптимальним (це не вогонь за власним бажанням,
це вогонь за наказом капітана або стріляти по дошці, брудний морський пес!)
Якщо всі відповіді "так", то Fire! якщо один або кілька "ні", тоді Shiver me timbers!
*/

// Мій варіант
const cannonsReady = (gunners) => {
    for (var i in gunners) {
        if (gunners[i] === "nay") {
            return "Shiver me timbers!"
        }
    }
    return "Fire!"
}

// Цікаві варіанти з Codewars


// ================================================================================================
// ================================================================================================
//*-Task №266 Training JS #18: Methods of String object--concat() split() and its good friend join() (8kyu)
/*
Реалізуйте функцію, яка приймає 2 аргументи: рядок і роздільник.
Очікуваний алгоритм: розбити рядок на слова за пробілами, розбити кожне слово на окремі символи та з’єднати
їх за допомогою вказаного роздільника, з’єднати всі отримані «слова» назад у речення з пробілами.
*/

// Мій варіант
function splitAndMerge(string, separator) {
    const words = string.split(' ');
    const result = words.map(word => {
        return word.split('').join(separator);
    })
    return result.join(' ');
}

// Цікаві варіанти з Codewars


// ================================================================================================
// ================================================================================================
//*-залишилось 116шт
// console.time('timer_1');
// console.timeEnd('timer_1');