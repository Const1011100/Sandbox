//*-Task №421 Don't give me five! (7kyu)
/*
Не дай мені п'ять!
У цій ката ви отримуєте початковий і кінцевий номер регіону, а також повинні повертати кількість
усіх чисел, крім чисел із 5. Початкове та кінцеве число включено!

Приклади:
1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12

Результат може містити п'ятірки. ;-)
Початкове число завжди буде меншим за кінцеве. Обидва числа можуть бути також негативними!
Мені дуже цікаві ваші рішення та те, як ви це вирішуєте.
Можливо, хтось із вас знайде легке чисто математичне рішення.

Насолоджуйтесь кодуванням і, будь ласка, не забудьте проголосувати та оцінити це ката! :-)
Я також створив інші ката. Подивіться, якщо вам сподобалася ця ката!
*/

// Мій варіант
function dontGiveMeFive(start, end) {
    const numbers = [];
    for (let i = start; i <= end; i++) {
        numbers.push(i);
    }
    return numbers.filter(number => {
        if (number.toString().includes('5')) {
            return false;
        }
        return true;
    }).length;
}

// Цікаві варіанти з Codewars
function dontGiveMeFive_(start, end) {
    let count = 0
    for (let i = start; i <= end; i++) {
        if (!/5/.test(i)) {
            count++
        }
    }
    return count
}
// ================================================================================================
// ================================================================================================
//*-Task №422 Sort array by string length (7kyu)
/*
Напишіть функцію, яка приймає масив рядків як аргумент і повертає відсортований масив, що містить ті
самі рядки, упорядковані від найкоротшого до найдовшого.

Наприклад, якщо цей масив передано як аргумент:
["Telescopes", "Glasses", "Eyes", "Monocles"]

Ваша функція поверне такий масив:
["Eyes", "Glasses", "Monocles", "Telescopes"]

Усі рядки в масиві, переданому вашій функції, будуть різної довжини, тому вам не доведеться вирішувати,
як упорядкувати кілька рядків однакової довжини.
*/

// Мій варіант
function sortByLength(array) {
    return array.sort((a, b) => {
        return a.length - b.length;
    });
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №423 Breaking chocolate problem (7kyu)
/*
Ваше завдання — розрізати плитку шоколаду заданих розмірів n x m на маленькі квадратики.
Кожен квадрат має розмір 1x1 і не розбивається. Реалізуйте функцію, яка повертатиме мінімальну
кількість необхідних розривів.

Наприклад, якщо вам дали плитку шоколаду розміром 2 х 1, ви можете розділити її на окремі квадрати
лише за один розрив, але для розміру 3 х 1 ви повинні зробити дві перерви.

Якщо вхідні дані недійсні, ви маєте повернути 0 (якщо перерви не потрібні, якщо у нас немає шоколаду
для розділення). Введення завжди буде невід’ємним цілим числом.
*/

// Мій варіант
function breakChocolate(n, m) {
    if (n <= 0 || m <= 0) { return 0 };
    return (n - 1) * m + (m - 1);
}
// Цікаві варіанти з Codewars
var breakChocolate_ = function (n, m) {
    return (n * m === 0) ? 0 : n * m - 1;
};
//
var breakChocolate__ = function (n, m) {
    return Math.max(0, m * n - 1);
};
// ================================================================================================
// ================================================================================================
//*-Task №424 Money, Money, Money (7kyu)
/*
Містер Скрудж має суму грошей «P», яку він хоче інвестувати. Перш ніж це зробити, він хоче знати,
скільки років «Y» цю суму «P» потрібно зберігати в банку, щоб вона склала бажану суму грошей «D».

Сума зберігається протягом «Y» років у банку, де щорічно виплачуються відсотки «I». Після сплати
податків «T» за рік нова сума реінвестується.

Примітка щодо податків: оподатковується не інвестована основна сума, а лише нараховані проценти за рік

Приклад:
Нехай P буде основним = 1000,00
Нехай I — процентна ставка = 0,05
Нехай T буде податковою ставкою = 0,18
Нехай D буде бажаною сумою = 1100,00

Після 1-го курсу --> P = 1041,00
Після 2 курсу --> P = 1083,86
Після 3 курсу --> P = 1128,30

Таким чином, містеру Скруджу доводиться чекати 3 роки, поки початкова сума не досягне бажаної суми.

Ваше завдання полягає в тому, щоб виконати запропонований метод і повернути кількість років «Y» в цілому,
щоб містер Скрудж отримав бажану суму.

Припущення: припустимо, що бажаний принципал «D» завжди більший за початковий принципал.
Однак найкраще взяти до уваги, що якщо бажаний принципал «D» дорівнює принципалу «P», це має повернути 0 років.
*/

// Мій варіант
function calculateYears(principal, interest, tax, desired) {
    let years = 0;
    let P = principal;

    while (P < desired) {
        let I = P * interest;
        let T = tax * I;
        let bonus = I - T;
        years++;
        P += bonus;
    }
    return years;
}
// Цікаві варіанти з Codewars
function calculateYears_(principal, interest, tax, desired) {
    var years = 0;
    while (principal < desired) {
        principal += (principal * interest) * (1 - tax);
        years++;
    }
    return years;
}
// ================================================================================================
// ================================================================================================
//*-Task №425 Count the Digit (7kyu)
/*
Візьміть ціле число n (n >= 0) і цифру d (0 <= d <= 9) як ціле число.
Зведіть у квадрат усі числа k (0 <= k <= n) від 0 до n.
Підрахуйте кількість цифр d, які використовуються для запису всіх k**2.
Реалізуйте функцію, приймаючи n і d як параметри та повертаючи цей підрахунок.

приклади:
n = 10, d = 1
k*k дорівнює 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
Ми використовуємо цифру 1 у: 1, 16, 81, 100. Тоді загальна кількість дорівнює 4.

Функція, якщо n = 25 і d = 1 як аргумент, має повернути 11, оскільки
k*k, які містять цифру 1:
1, 16, 81, 100, 121, 144, 169, 196, 361, 441.
Отже, є 11 цифр 1 для квадратів чисел від 0 до 25.
Зауважте, що 121 має подвоєну цифру 1.
*/

// Мій варіант
function nbDig(n, d) {
    let count = 0;

    const digit = d.toString();
    const regExp = new RegExp(`${digit}`, 'g');

    for (let i = 0; i <= n; i++) {
        const square = i * i;
        const matches = `${square}`.match(regExp);
        if (matches) {
            count += matches.length;
        }
    }

    return count;
}
// Цікаві варіанти з Codewars
function nbDig_(n, d) {
    var res = 0;
    for (var g = 0; g <= n; g++) {
        var square = (g * g + "").split("");
        square.forEach((s) => s == d ? res++ : null)
    }
    return res;
}
//
function nbDig__(n, d) {
    var o = '';
    for (var i = 0; i <= n; i++) {
        o += Math.pow(i, 2);
    }
    return o.split(d).length - 1
}
// ================================================================================================
// ================================================================================================
//*-Task №426 Make a function that does arithmetic! (7kyu)
/*
Дано два числа та арифметичний оператор (його ім’я у вигляді рядка), поверніть результат двох чисел,
для яких використовується цей оператор.

a і b обидва будуть натуральними числами, і a завжди буде першим числом в операції, а b завжди другим.

Чотири оператори: «додати», «відняти», «поділити», «помножити».
Кілька прикладів: (Вхід 1, Вхід 2, Вхід 3 --> Вихід)
5, 2, "add"      --> 7
5, 2, "subtract" --> 3
5, 2, "multiply" --> 10
5, 2, "divide"   --> 2.5
Спробуйте зробити це без використання операторів if!
*/

// Мій варіант
function arithmetic(a, b, operator) {
    const operators = {
        'add': a + b,
        'subtract': a - b,
        'multiply': a * b,
        'divide': a / b,
    }
    return operators[operator];
}
// Цікаві варіанти з Codewars
function arithmetic_(a, b, operator) {
    switch (operator) {
        case 'add':
            return a + b;
        case 'subtract':
            return a - b;
        case 'multiply':
            return a * b;
        case 'divide':
            return a / b;
    }
}
// ================================================================================================
// ================================================================================================
//*-залишилось 1935шт
// console.time('timer_1');
// console.timeEnd('timer_1');