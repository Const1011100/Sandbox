//*-Task №421 Don't give me five! (7kyu)
/*
Не дай мені п'ять!
У цій ката ви отримуєте початковий і кінцевий номер регіону, а також повинні повертати кількість
усіх чисел, крім чисел із 5. Початкове та кінцеве число включено!

Приклади:
1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12

Результат може містити п'ятірки. ;-)
Початкове число завжди буде меншим за кінцеве. Обидва числа можуть бути також негативними!
Мені дуже цікаві ваші рішення та те, як ви це вирішуєте.
Можливо, хтось із вас знайде легке чисто математичне рішення.

Насолоджуйтесь кодуванням і, будь ласка, не забудьте проголосувати та оцінити це ката! :-)
Я також створив інші ката. Подивіться, якщо вам сподобалася ця ката!
*/

// Мій варіант
function dontGiveMeFive(start, end) {
    const numbers = [];
    for (let i = start; i <= end; i++) {
        numbers.push(i);
    }
    return numbers.filter(number => {
        if (number.toString().includes('5')) {
            return false;
        }
        return true;
    }).length;
}

// Цікаві варіанти з Codewars
function dontGiveMeFive_(start, end) {
    let count = 0
    for (let i = start; i <= end; i++) {
        if (!/5/.test(i)) {
            count++
        }
    }
    return count
}
// ================================================================================================
// ================================================================================================
//*-Task №422 Sort array by string length (7kyu)
/*
Напишіть функцію, яка приймає масив рядків як аргумент і повертає відсортований масив, що містить ті
самі рядки, упорядковані від найкоротшого до найдовшого.

Наприклад, якщо цей масив передано як аргумент:
["Telescopes", "Glasses", "Eyes", "Monocles"]

Ваша функція поверне такий масив:
["Eyes", "Glasses", "Monocles", "Telescopes"]

Усі рядки в масиві, переданому вашій функції, будуть різної довжини, тому вам не доведеться вирішувати,
як упорядкувати кілька рядків однакової довжини.
*/

// Мій варіант
function sortByLength(array) {
    return array.sort((a, b) => {
        return a.length - b.length;
    });
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №423 Breaking chocolate problem (7kyu)
/*
Ваше завдання — розрізати плитку шоколаду заданих розмірів n x m на маленькі квадратики.
Кожен квадрат має розмір 1x1 і не розбивається. Реалізуйте функцію, яка повертатиме мінімальну
кількість необхідних розривів.

Наприклад, якщо вам дали плитку шоколаду розміром 2 х 1, ви можете розділити її на окремі квадрати
лише за один розрив, але для розміру 3 х 1 ви повинні зробити дві перерви.

Якщо вхідні дані недійсні, ви маєте повернути 0 (якщо перерви не потрібні, якщо у нас немає шоколаду
для розділення). Введення завжди буде невід’ємним цілим числом.
*/

// Мій варіант
function breakChocolate(n, m) {
    if (n <= 0 || m <= 0) { return 0 };
    return (n - 1) * m + (m - 1);
}
// Цікаві варіанти з Codewars
var breakChocolate_ = function (n, m) {
    return (n * m === 0) ? 0 : n * m - 1;
};
//
var breakChocolate__ = function (n, m) {
    return Math.max(0, m * n - 1);
};
// ================================================================================================
// ================================================================================================
//*-залишилось 1936шт
// console.time('timer_1');
// console.timeEnd('timer_1');