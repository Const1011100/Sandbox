//*-Task №801 Find all occurrences of an element in an array (7kyu)
/*
Дано масив цілих чисел та ціле число n.
Знайдіть усі входження n у заданий масив та поверніть інший масив,
що містить усі індексні позиції n у заданому масиві.

Якщо n немає у заданому масиві, поверніть порожній масив [].

Вважайте, що n та всі значення у заданому масиві завжди будуть цілими числами.

Приклад:
findAll([6, 9, 3, 4, 3, 82, 11], 3) => [2, 4]
*/

// Мій варіант
function findAll(array, n) {
  const result = [];
  array.forEach((number, i) => {
    if (number === n) {
      result.push(i);
    }
  });
  return result;
}
// Цікаві варіанти від GPT
const findAll_ = (arr, n) =>
  arr.map((v, i) => (v === n ? i : -1)).filter((i) => i !== -1);
// ================================================================================================
// ================================================================================================
//*-Task №802 Regexp Basics - is it a letter? (7kyu)
/*
Доповніть код, який має повертати значення true, якщо заданий об'єкт є однією літерою ASCII
(нижньою чи верхньою), в іншому випадку — значення false.
String.prototype.isLetter = function() {
}
*/

// Мій варіант
String.prototype.isLetter = function () {
  return /^[a-zA-Z]$/.test(this);
};
// Цікаві варіанти від GPT

// ================================================================================================
// ================================================================================================
//*-Task №803 Find the calculation type (7kyu)
/*
Вам потрібно створити функцію, яка отримує 3 числові аргументи: 2 операнди a та b,
а також результат невідомої операції, виконаної над ними.

На основі цих 3 значень вам потрібно повернути рядок, який описує, яка операція була використана
для отримання заданого результату.

Можливі рядки повернення: "addition", "addition", "multiplication", "division".

Приклади:
(a = 1, b = 2, результат = 3) --> 1 ? 2 = 3 --> "addition"
(a = 5, b = 2, результат = 2.5) --> 5 ? 2 = 2.5 --> "division"
Примітки
Оператор / виконує просте ділення без округлення.
Можна припустити, що завжди буде єдина правильна відповідь (немає неоднозначних випадків, таких як,
наприклад, 1 ? 0 = 0, що може бути - або +, або 3 ? 1 = 3, що може бути * або /).
Можна припустити, що ділення на 0 не буде
*/

// Мій варіант
function calcType(a, b, res) {
  if (a + b === res) return 'addition';
  if (a - b === res) return 'subtraction';
  if (a * b === res) return 'multiplication';
  if (a / b === res) return 'division';
}
// Цікаві варіанти з Codewars
const calcType_ = (a, b, res) =>
  ({
    [a + b]: `addition`,
    [a - b]: `subtraction`,
    [a * b]: `multiplication`,
    [a / b]: `division`,
  }[res]);
//
function calcType__(a, b, res) {
  switch (res) {
    case a + b:
      return 'addition';
    case a - b:
      return 'subtraction';
    case a / b:
      return 'division';
    case a * b:
      return 'multiplication';
  }
}

// ================================================================================================
// ================================================================================================
//*-Task №804 Odder Than the Rest (7kyu)
/*
Створіть метод, який приймає масив як вхідні дані та виводить індекс, за яким знаходиться
єдине непарне число.

Цей метод має працювати з масивами з від'ємними числами. Якщо в масиві немає непарних чисел,
то метод має виводити -1.

Приклади:
oddOne([2,4,6,7,10]) // => 3
oddOne([2,16,98,10,13,78]) // => 4
oddOne([4,-8,98,-12,-7,90,100]) // => 4
oddOne([2,4,6,8]) // => -1
*/

// Мій варіант
function oddOne(arr) {
  return arr.indexOf(arr.find((n) => n % 2 !== 0));
}
// Цікаві варіанти з Codewars
function oddOne_(arr) {
  return arr.findIndex((x) => x % 2 !== 0);
}
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
//*-Task №805 Return a sorted list of objects (7kyu)
/*
Вам буде передано масив об'єктів (список) - ви повинні відсортувати їх у порядку спадання
на основі значення вказаної властивості (sortBy).

Приклад
Під час сортування за "a", це:

[
{"a": 1, "b": 3},
{"a": 3, "b": 2},
{"a": 2, "b": 40},
{"a": 4, "b": 12}
]
має повернути:

[
{"a": 4, "b": 12},
{"a": 3, "b": 2},
{"a": 2, "b": 40},
{"a": 1, "b": 3}
]
Значення завжди будуть числами, а властивості завжди існуватимуть.
*/

// Мій варіант
function sortList(sortBy, list) {
  return list.sort((a, b) => a[sortBy] - b[sortBy]);
}
// Цікаві варіанти з Codewars
function sortList_(sortBy, list) {
  return list.sort(function (a, b) {
    return a[sortBy] < b[sortBy];
  });
}
// ================================================================================================
// ================================================================================================
//*-Task №806 Get key/value pairs as arrays (7kyu)
/*
Доповніть функцію keysAndValues ​​так, щоб вона приймала об'єкт і повертала ключі та значення як
окремі масиви.

Приклад:

keysAndValues({a: 1, b: 2, c: 3}) // має повертати [['a', 'b', 'c'], [1, 2, 3]]
Стильові точки (лише JS/CoffeeScript): Цей ката перевіряє лише дані, що використовують нотацію
об'єктів-літерал (прості об'єкти). Для додаткового стилю, чи можете ви зробити так, щоб ваш метод
перевіряв об'єкти, які розширюють їхній прототип?
*/

// Мій варіант
function keysAndValues(data) {
  const keys = Object.keys(data);
  const values = Object.values(data);
  return [keys, values];
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №807 Filter unused digits (7kyu)
/*
Враховуючи різну кількість цілочисельних аргументів, поверніть цифри, яких немає в жодному з них.
Приклад:
[12, 34, 56, 78] => "09"
[2015, 8, 26] => "3479"
Примітка: цифри в результуючому рядку мають бути відсортовані.
*/

// Мій варіант
function unusedDigits() {
  const result = [];
  const newArr = [...arguments].join('');
  for (let i = 0; i < 10; i++) {
    if (!newArr.includes(`${i}`)) {
      result.push(i);
    }
  }
  return result.join('');
}
// Цікаві варіанти з Codewars
const unusedDigits_ = (...arr) => {
  var digits = arr.join();

  return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    .filter((x) => !digits.includes(x))
    .join('');
};
// ================================================================================================
// ================================================================================================
//*-Task №808 Bubblesort Once (7kyu)
/*
Огляд
Бульбашкове сортування – це неефективний алгоритм сортування, який легко зрозуміти, і тому його
часто викладають на вступних курсах з інформатики як приклад того, як не слід сортувати список.
Тим не менш, він правильний у тому сенсі, що зрештою створює відсортовану версію вихідного списку,
коли виконується до кінця.

В основі бульбашкового сортування лежить те, що називається проходом. Давайте розглянемо приклад
того, як працює прохід.

Розглянемо наступний список:
9, 7, 5, 3, 1, 2, 4, 6, 8
Ми ініціюємо прохід, порівнюючи перші два елементи списку. Чи перший елемент більший за другий?
Якщо так, ми міняємо місцями два елементи. Оскільки 9 у цьому випадку більше за 7, ми міняємо їх
місцями, щоб отримати 7, 9. Список тоді стає таким:

7, 9, 5, 3, 1, 2, 4, 6, 8
Потім ми продовжуємо процес для 2-го та 3-го елементів, 3-го та 4-го елементів... аж до двох
останніх елементів. Коли прохід завершено, наш список стає таким:

7, 5, 3, 1, 2, 4, 6, 8, 9
Зверніть увагу, що найбільше значення 9 "піднялося" до кінця списку. Саме так Bubblesort отримав
свою назву.

Завдання
Враховуючи масив цілих чисел, ваша функція повинна повернути новий масив, еквівалентний виконанню
рівно 1 повного проходу по вихідному масиву. Ваша функція повинна бути чистою, тобто вона не
повинна змінювати вхідний масив.
*/

// Мій варіант
function bubblesortOnce(a) {
  const newArr = [...a];

  for (let i = 0; i < newArr.length - 1; i++) {
    if (newArr[i] > newArr[i + 1]) {
      [newArr[i], newArr[i + 1]] = [newArr[i + 1], newArr[i]];
    }
  }

  return newArr;
}
// Цікаві варіанти з Codewars

function bubblesortOnce_(arr) {
  let newArr = arr.slice();
  for (let i = 0; i < newArr.length - 1; i++) {
    if (newArr[i] > newArr[i + 1]) {
      [newArr[i], newArr[i + 1]] = [newArr[i + 1], newArr[i]];
    }
  }
  return newArr;
}
// ================================================================================================
// ================================================================================================
//*-Task №809 Regexp Basics - is it a vowel? (7kyu)
/*
Реалізуйте функцію, яка повинна повертати значення true, якщо заданий об'єкт є голосною літерою]
(тобто a, e, i, o, u, верхнього чи нижнього регістру), та false в іншому випадку.
*/

// Мій варіант
String.prototype.vowel = function () {
  const str = this.toString();
  if (str.length !== 1) return false;
  return /^[aeiou]$/i.test(str);
};
// Цікаві варіанти з Codewars
String.prototype.vowel_ = function () {
  return /^[aeiou]$/i.test(this);
};
// ================================================================================================
// ================================================================================================
//*-Task №810 Letterbox Paint-Squad (7kyu)
/*
Ви та група друзів заробляєте додаткові гроші під час шкільних канікул, перефарбовуючи цифри на
поштових скриньках людей за невелику плату.

Оскільки вас у групі 10, кожна людина зосереджується на малюванні лише однієї цифри!
Наприклад, хтось малює лише одиниці, хтось інший — лише двійки тощо...

Але зрештою ви розумієте, що не всі виконали однакову кількість роботи.
Щоб уникнути сварок, потрібно справедливо розподілити гроші. Ось тут і з'являється ката.

Завдання ката
Враховуючи початковий та кінцевий номери поштових скриньок, напишіть метод, який повертає частоту
всіх 10 намальованих цифр.

Приклад
Для початку = 125 та кінця = 132

Листові скриньки:

125 = 1, 2, 5
126 = 1, 2, 6
127 = 1, 2, 7
128 = 1, 2, 8
129 = 1, 2, 9
130 = 1, 3, 0
131 = 1, 3, 1
132 = 1, 3, 2
Частоти розрядів:

0 відображаються 1 раз
1 відображаються 9 разів
2 відображаються 6 разів
тощо...
і тому метод поверне [1,9,6,3,0,1,1,1,1,1]

Примітки
0 < початок <= кінець
У C та NASM повернене значення буде звільнено.
*/

// Мій варіант
var paintLetterboxes = function (start, end) {
  const table = {
    0: 0,
    1: 0,
    2: 0,
    3: 0,
    4: 0,
    5: 0,
    6: 0,
    7: 0,
    8: 0,
    9: 0,
  };
  for (let i = start; i <= end; i++) {
    const array = i.toString().split('');
    array.forEach((n) => {
      table[n]++;
    });
  }
  return Object.values(table);
};
// Цікаві варіанти з Codewars
const paintLetterboxes_ = (start, end) => {
  let res = Array(10).fill(0);
  for (let i = start; i <= end; i++) {
    for (let n of i + '') {
      res[n]++;
    }
  }
  return res;
};
//
function paintLetterboxes__(start, end) {
  const frequencies = new Array(10).fill(0);
  for (let number = start; number <= end; number++) {
    number
      .toString()
      .split('')
      .forEach((x) => frequencies[x]++);
  }
  return frequencies;
}
// ================================================================================================
// ================================================================================================
//*-Task №811 Only one (7kyu)
/*
Завдання: Написати функцію only_one, яка повертає True, якщо ЛИШЕ ОДИН з логічних прапорців має
значення True, інакше повертає False. Якщо логічних прапорців немає, повертає False

onlyOne() --> false
onlyOne(true, false, false) --> true
onlyOne(true, false, false, true) --> false
onlyOne(false, false, false, false) --> false
*/

// Мій варіант
function onlyOne(...args) {
  if (args.length < 1) return false;
  return args.filter((element) => element === true).length === 1;
}
// Цікаві варіанти з Codewars
const onlyOne_ = (...args) => args.filter(Boolean).length === 1;
// ================================================================================================
// ================================================================================================
//*-Task №812 Fruit string calculator (7kyu)
/*
Вам задано рядок слів і чисел. Витягніть вираз, включаючи:

оператор: додавання ("gains") або віднімання ("loses")
два числа, над якими ми працюємо
Поверніть результат обчислення.

Примітки:

"loses" та "gains" - єдині два слова, що описують оператори
Ні фруктових боргів, ні надкушених яблук = Числа є цілими числами та без від'ємних чисел
Приклади
"Панда має 48 яблук і програє 4" --> 44
"Джеррі має 34 яблука і виграє 6" --> 40
Має бути гарненьке невелике ката для вас :)
*/

// Мій варіант
function calculate(string) {
  const words = string.split(' ');
  let numbers = words
    .filter((e) => {
      return !isNaN(Number(e));
    })
    .map((e) => Number(e));

  if (words.includes('gains')) {
    return numbers[0] + numbers[1];
  }
  if (words.includes('loses')) {
    return numbers[0] - numbers[1];
  }
}
// Цікаві варіанти з Codewars
function calculate_(string) {
  return eval(
    string
      .replace('loses', '-')
      .replace('gains', '+')
      .replace(/[a-zA-Z]/g, '')
  );
}
//
function calculate__(str) {
  // Add your code here:
  let [op1, op2] = str.match(/\d+/gm);
  return /loses/.test(str) ? +op1 - +op2 : +op1 + +op2;
}
// ================================================================================================
// ================================================================================================
//*-Task №813 filterEvenLengthWords (7kyu)
/*
Дано масив рядків. Напишіть функцію, яка повертає масив, що містить лише елементи заданого масиву,
довжина якого є парним числом.

Приклад
["One", "Two", "Three", "Four"] --> ["Four"]
*/

// Мій варіант
function filterEvenLengthWords(words) {
  return words.filter((element) => element.length % 2 === 0);
}

// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №814 Compare Strings by Sum of Chars (7kyu)
/*
Порівняйте два рядки, порівнюючи суму їхніх значень (код символу ASCII).

Для порівняння всі літери розглядаються як верхній регістр.
null слід розглядати як порожні рядки.
Якщо рядок містить інші символи, окрім літер, весь рядок розглядається як порожній.
Ваш метод повинен повертати true, якщо рядки рівні, та false, якщо вони не рівні.

Приклади:
"AD", "BC"  -> equal
"AD", "DD"  -> not equal
"gf", "FG"  -> equal
"zz1", ""   -> equal (both are considered empty)
"ZzZz", "ffPFF" -> equal
"kl", "lz"  -> not equal
null, ""    -> equal
*/

// Мій варіант
function compare(s1, s2) {
  function sum(s) {
    let a = (s || '').toUpperCase().split('');
    return a.every((v) => /[A-Z]/.test(v))
      ? a.reduce((r, v) => r + v.codePointAt(0), 0)
      : 0;
  }
  return sum(s1) === sum(s2);
}
// Цікаві варіанти з Codewars
function compare_(s1, s2) {
  if (/^\D+$/gi.test(s1) && /^\D+$/gi.test(s2))
    return (
      s1
        .split('')
        .map((n) => n.toUpperCase().charCodeAt())
        .reduce((a, b) => a + b) ===
      s2
        .split('')
        .map((n) => n.toUpperCase().charCodeAt())
        .reduce((a, b) => a + b)
    );
  return true;
}
// ================================================================================================
// ================================================================================================
//*-Task №815 Combine objects (7kyu)
/*
Ваше завдання — написати функцію, яка приймає два або більше об'єктів та повертає новий об'єкт,
що об'єднує всі вхідні об'єкти.

Усі властивості вхідних об'єктів матимуть лише числові значення. Об'єкти об'єднуються разом таким
чином, що значення співпадаючих ключів додаються.

Приклад:

const objA = { a: 10, b: 20, c: 30 }
const objB = { a: 3, c: 6, d: 3 }
combine(objA, objB) // Повертає { a: 13, b: 20, c: 36, d: 3 }
Функція combine повинна бути добросовісною, тому не повинна змінювати вхідні об'єкти.
*/

// Мій варіант
function combine(...objects) {
  const keys = Array.from(new Set(objects.flatMap((obj) => Object.keys(obj))));
  const result = {};
  keys.forEach((key) => {
    result[key] = objects.reduce((sum, obj) => {
      return sum + (obj[key] || 0);
    }, 0);
  });
  return result;
}
// Цікаві варіанти з Codewars
const combine_ = (...params) =>
  params.reduce((a, b) => {
    for (const x in b) {
      a[x] = x in a ? a[x] + b[x] : b[x];
    }
    return a;
  }, {});
// ================================================================================================
// ================================================================================================
//*-Task №816 Odds-Index (7kyu)
/*
Вам задано масив з кількома парними словами, одним непарним словом та деякими числами.
Визначте, чи є якесь із чисел у масиві індексом непарного слова.
Якщо так, поверніть значення true, інакше false.
*/

// Мій варіант
function oddBall(arr) {
  const oddIndex = arr.findIndex(
    (item) => typeof item === 'string' && item.length % 2 !== 0
  );

  return arr.some((item) => typeof item === 'number' && item === oddIndex);
}
// Цікаві варіанти з Codewars
function oddBall_(arr) {
  return arr.includes(arr.indexOf('odd'));
}
// ================================================================================================
// ================================================================================================
//*-Task №817 noobCode 04: HOT SINGLES...compare two arrays, return the unpaired items ! (7kyu)
/*
Напишіть функцію, яка приймає два аргументи масиву та повертає новий масив, заповнений елементами,
що з'являються в будь-якому масиві, але не в обох.
Елементи повинні з'являтися в повернутому масиві лише один раз.

Порядок елементів у результаті має відповідати порядку розташування в першому масиві, а потім у другому.

Приклади
[1, 2, 3, 3], [3, 2, 1, 4, 5] --> [4, 5]
["tartar", "blanket", "cinnamon"], ["cinnamon", "blanket", "domino"] --> ["tartar", "domino"]
[77, "ciao"], [78, 42, "ciao"] --> [77, 78, 42]
[1, 2, 3, 3], [3, 2, 1, 4, 5, 4] --> [4,5]
[1, 2, 3] , [3, 3, 2, 1] --> []
*/

// Мій варіант
function hotSingles(arr1, arr2) {
  // Створюємо Set для кожного масиву (автоматично видаляє дублікати)
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);

  const result = [];

  // Додаємо елементи з першого масиву, яких немає в другому
  for (const item of set1) {
    if (!set2.has(item)) {
      result.push(item);
    }
  }

  // Додаємо елементи з другого масиву, яких немає в першому
  for (const item of set2) {
    if (!set1.has(item)) {
      result.push(item);
    }
  }

  return result;
}

// Цікаві варіанти з Codewars
const hotSingles_ = (arr1, arr2) =>
  [...new Set([...arr1, ...arr2])].filter(
    (val) => !arr1.includes(val) || !arr2.includes(val)
  );
// ================================================================================================
// ================================================================================================
//*-Task №818 Likes Vs Dislikes (7kyu)
/*
Історія
На YouTube були кнопки «подобається» та «не подобається», які дозволяли користувачам висловлювати
свою думку щодо певного контенту. Він був налаштований таким чином, що ви не можете одночасно ставити
«подобається» та «не подобається» відео. Є ще два цікавих правила інтерфейсу, які варто зазначити:
Натискання кнопки, яка вже активна, скасовує ваше натискання. Якщо ви натискаєте кнопку «подобається»
після натискання кнопки «не подобається», кнопка «подобається» перезаписує попередній стан
«не подобається». Те саме стосується і навпаки.

Завдання
Створіть функцію, яка приймає список введених даних кнопок та повертає кінцевий стан.

Приклади
likeOrDislike([Dislike]) => Dislike
likeOrDislike([Like,Like]) => Nothing
likeOrDislike([Dislike,Like]) => Like
likeOrDislike([Like,Dislike,Dislike]) => Nothing
Примітки
Якщо жодна кнопка наразі не активна, повернути Нічого.
Якщо список порожній, повернути Нічого.
*/

// Мій варіант
function likeOrDislike(buttons) {
  let state = 'Nothing';

  for (const button of buttons) {
    if (state === button) {
      state = 'Nothing';
    } else {
      state = button;
    }
  }

  return state;
}

// Цікаві варіанти з Codewars
function likeOrDislike_(buttons) {
  return buttons.reduce(
    (state, button) => (button === state ? Nothing : button),
    Nothing
  );
}
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
