//*-Task №721 Stanton measure (7kyu)
/*
Міра Стентона масиву обчислюється наступним чином:
Підрахуйте кількість входжень значення 1 у масив і нехай ця кількість дорівнює n.
Міра Стентона – це кількість разів, коли n з'являється в масиві.

Напишіть функцію, яка приймає цілочисельний масив і повертає його міру Стентона.

Приклади
Міра Стентона масиву [1, 4, 3, 2, 1, 2, 3, 2] дорівнює 3, оскільки 1 зустрічається в масиві 2 рази,
а 2 зустрічається 3 рази.

Міра Стентона масиву [1, 4, 1, 2, 11, 2, 3, 1] дорівнює 1, оскільки 1 зустрічається в масиві 3 рази,
а 3 зустрічається 1 раз.
*/

// Мій варіант
function stantonMeasure(a) {
  const n = a.reduce((sum, num) => {
    return num === 1 ? sum + num : sum;
  }, 0);
  const result = a.reduce((sum, num) => {
    return num === n ? sum + 1 : sum;
  }, 0);
  return result;
}
// Цікаві варіанти з Codewars
function stantonMeasure_(arr) {
  const count = (n) => arr.filter((x) => x === n).length;
  return count(count(1));
}
// ================================================================================================
// ================================================================================================
//*-Task №722 Create Phone Number (6kyu)
/*
Напишіть функцію, яка приймає масив із 10 цілих чисел (від 0 до 9) та повертає рядок цих чисел
у вигляді номера телефону.

Приклад
createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => повертає "(123) 456-7890"
Повернений формат має бути правильним для виконання цього завдання.

Не забудьте пробіли після закриваючих дужок!
*/

// Мій варіант
function createPhoneNumber(numbers) {
  return `${
    '(' +
    numbers[0] +
    numbers[1] +
    numbers[2] +
    ')' +
    ' ' +
    '' +
    numbers[3] +
    numbers[4] +
    numbers[5] +
    '-' +
    '' +
    numbers[6] +
    numbers[7] +
    numbers[8] +
    numbers[9]
  }`;
}
// Цікаві варіанти з Codewars
function createPhoneNumber_(numbers) {
  var format = '(xxx) xxx-xxxx';

  for (var i = 0; i < numbers.length; i++) {
    format = format.replace('x', numbers[i]);
  }

  return format;
}
//
function createPhoneNumber__(numbers) {
  numbers = numbers.join('');
  return (
    '(' +
    numbers.substring(0, 3) +
    ') ' +
    numbers.substring(3, 6) +
    '-' +
    numbers.substring(6)
  );
}
//
function createPhoneNumber___(numbers) {
  return numbers.reduce((p, c) => p.replace('x', c), '(xxx) xxx-xxxx');
}
//
function createPhoneNumber____(numbers) {
  return numbers.join('').replace(/(...)(...)(.*)/, '($1) $2-$3');
}
// ================================================================================================
// ================================================================================================
//*-Task №723 Duplicate Encoder (6kyu)
/*
Мета цієї вправи — перетворити рядок на новий рядок, де кожен символ у новому рядку буде
"(", якщо цей символ з'являється лише один раз у вихідному рядку, або ")", якщо цей символ
з'являється більше одного разу у вихідному рядку. Ігноруйте використання великих літер під час
визначення, чи є символ дублікатом.

Приклади
"din" => "((("
"recede" => "()()()"
"Success" => ")()())"
"(( @" => "))(("
Примітки
Повідомлення про твердження можуть бути незрозумілими щодо того, що вони відображають деякими мовами.
Якщо ви читаєте "...It Should encode XXX", "XXX" — це очікуваний результат, а не вхідні дані!
*/

// Мій варіант
function duplicateEncode(word) {
  const letters = word.split('');
  const result = letters.map((l) => {
    const escapedChar = l.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const reg = new RegExp(escapedChar, 'gi');
    return word.match(reg).length > 1 ? ')' : '(';
  });
  return result.join('');
}

// Цікаві варіанти з Codewars
function duplicateEncode_(word) {
  return word
    .toLowerCase()
    .split('')
    .map(function (a, _, w) {
      return w.indexOf(a) == w.lastIndexOf(a) ? '(' : ')';
    })
    .join('');
}
// ================================================================================================
// ================================================================================================
//*-Task №724 Bingo ( Or Not ) (6kyu)
/*
Для цієї гри в BINGO ви отримаєте на вхід один масив із 10 чисел від 1 до 26.
У масиві можливі дублікати чисел.

Кожне число відповідає літері алфавітного порядку (наприклад, 1 = A, 2 = B тощо).
Напишіть функцію, в якій ви виграєте гру, якщо ваші числа можуть написати 'BINGO'.
Вони не обов'язково повинні бути в правильному порядку у вхідному масиві.
В іншому випадку ви програєте. Ваші вихідні дані повинні бути 'WIN' або 'LOSE' відповідно.
*/

// Мій варіант
function bingo(a) {
  const bingoList = [2, 9, 14, 7, 15];
  for (let i = 0; i < bingoList.length; i++) {
    if (!a.includes(bingoList[i])) {
      return 'LOSE';
    }
  }
  return 'WIN';
}
// Цікаві варіанти з Codewars
const bingo_ = (ar) =>
  [2, 7, 9, 14, 15].every((e) => ar.includes(e)) ? 'WIN' : 'LOSE';
// ================================================================================================
// ================================================================================================
//*-Task №725 Unpacking Arguments (7kyu)
/*
Ви повинні створити функцію spread, яка приймає функцію та список аргументів, що застосовуються
до цієї функції. Ви повинні зробити так, щоб ця функція повертала результат виклику заданої функції
 з заданими аргументами.

Наприклад:
spread(someFunction, [1, true, "Foo", "bar"] ) 
// is the same as...
someFunction(1, true, "Foo", "bar")
*/

// Мій варіант
function spread(func, args) {
  return func(...args);
}
// Цікаві варіанти з Codewars
function spread_(func, args) {
  return func.apply(this, args);
}
// ================================================================================================
// ================================================================================================
//*-Task №726 Orthogonal Vectors (7kyu)
/*
Припустимо, що в мене є два вектори: (a1, a2, a3, ..., aN) та (b1, b2, b3, ..., bN).
Скалярний добуток між цими двома векторами визначається як:

a1*b1 + a2*b2 + a3*b3 + ... + aN*bN
Вектори класифікуються як ортогональні, якщо скалярний добуток дорівнює нулю.

Заповніть функцію, яка приймає дві послідовності як вхідні дані та повертає true, якщо вектори
ортогональні, та false, якщо вони не ортогональні. Послідовності завжди будуть правильно відформатовані
та однакової довжини, тому немає потреби спочатку перевіряти їх.

Приклади
[1, 1, 1], [2, 5, 7] --> false
[1, 0, 0, 1], [0, 1, 1, 0] --> true
*/

// Мій варіант

function isOrthogonal(vector1, vector2) {
  let dotProduct = 0;
  for (let i = 0; i < vector1.length; i++) {
    dotProduct += vector1[i] * vector2[i];
  }
  return dotProduct === 0;
}
// Цікаві варіанти з Codewars
function isOrthogonal_(u, v) {
  return !u.reduce((s, n, i) => s + n * v[i], 0);
}
// ================================================================================================
// ================================================================================================
//*-Task №727 80's Kids #2: Help ALF Find His Spaceship (7kyu)
/*
Пізно вчора ввечері в будинку Таннерів Альф ремонтував свій космічний корабель, щоб повернутися
до Мелмака. На жаль для нього, він забув увімкнути стоянкове гальмо, і космічний корабель злетів
під час ремонту. Тепер він зависає в космосі.
Альф має технологію, щоб повернути космічний корабель додому,
якщо він зможе зафіксувати його місцезнаходження.

Завдяки карті:
..........
..........
..........
.......X..
..........
.........

Мапа буде задана у вигляді рядка з символами \n, що розділяють нові рядки.
Нижній лівий кут карти — це [0, 0]. X — це космічний корабель ALF.
У цьому прикладі:
findSpaceship(map) => [7, 2]
Якщо ви не можете знайти космічний корабель, результат має бути таким:

"Spaceship lost forever."
*/

// Мій варіант
function findSpaceship(map = '') {
  if (!map.includes('X')) {
    return 'Spaceship lost forever.';
  }
  map = map.split('\n').reverse();
  let X = null;
  let Y = null;
  for (let i = 0; i < map.length; i++) {
    if (map[i].includes('X')) {
      Y = i;
      map[i].split('').forEach((e, i) => {
        if (e === 'X') {
          X = i;
        }
      });
    }
  }
  return [X, Y];
}
// Цікаві варіанти з Codewars
const findSpaceship_ = (map = '') => {
  map = map.split('\n').reverse();

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      if (map[y][x] === 'X') return [x, y];
    }
  }

  return 'Spaceship lost forever.';
};
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
