//*-Task №821 Simple fibonacci strings (7kyu)
/*
Враховуючи, що

f0 = '0'
f1 = '01'
f2 = '010' = f1 + f0
f3 = '01001' = f2 + f1
Вам буде задано число, і ваше завдання — повернути n-й рядок Фібоначчі. Наприклад:

solve(2) = '010'
solve(3) = '01001'
Більше прикладів у тестових випадках. Удачі!

Якщо вам подобаються послідовні ката, вам сподобається цей ката: Simple Prime Streaming
*/

// Мій варіант
function solve(n) {
  if (n === 0) return '0';
  if (n === 1) return '01';
  let a = '0'; // f0
  let b = '01'; // f1
  for (let i = 2; i <= n; i++) {
    const c = b + a; // fn = f(n-1) + f(n-2)
    a = b;
    b = c;
  }
  return b;
}
// Цікаві варіанти з Codewars
const solve_ = (n) =>
  n === 0 ? '0' : n === 1 ? '01' : solve(n - 1) + solve(n - 2);
// ================================================================================================
// ================================================================================================
//*-Task №822 Determine if the poker hand is flush (7kyu)
/*
Визначити, чи є покерна рука флешем, тобто чи п'ять карт однієї масті.

Вашій функції буде передано масив із 5 рядків, кожен з яких представляє покерну карту у
форматі "5H" (5 червів), що означає значення карти, а потім початкову літеру її масті
(Hearts, Spades, Diamonds or Clubs). Джокерів не враховувати.

Ваша функція повинна повернути значення true, якщо рука флеш, в іншому випадку значення false.

Можливі значення карт: 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A

Приклади
["AS", "3S", "9S", "KS", "4S"]  ==> true

["AD", "4S", "7H", "KS", "10S"] ==> false
*/

// Мій варіант
function isFlush(cards) {
  for (let i = 1; i < cards.length; i++) {
    if (cards[0][cards[0].length - 1] !== cards[i][cards[i].length - 1]) {
      return false;
    }
  }
  return true;
}
// Цікаві варіанти з Codewars
function isFlush_(cards) {
  return cards.every((a) => cards[0].slice(-1) === a.slice(-1));
}
// ================================================================================================
// ================================================================================================
//*-Task №823 makeBackronym (7kyu)
/*
Акронім, навмисно утворений з фрази, початкові літери якої позначають певне слово або слова,
або для створення назви, що запам'ятовується, або як вигадливе пояснення походження слова.

"Біорізноманіття, що служить нашій нації", або BISON

(з https://en.oxforddictionaries.com/definition/backronym)

Заповніть функцію для створення бекронімів. Перетворіть заданий рядок (без пробілів) на бекронім,
використовуючи попередньо завантажений словник, і поверніть рядок слів, розділених одним пробілом
(але без пробілів у кінці).

Ключі попередньо завантаженого словника - це великі літери A-Z, а значення - заздалегідь визначені
слова, наприклад:
dict["P"] == "perfect"
Examples
"dgm" ==> "disturbing gregarious mustache"

"lkj" ==> "literal klingon joke"
*/

// Мій варіант
var makeBackronym = function (string) {
  return string
    .toUpperCase() // Перетворюємо на великі літери
    .split('') // Розбиваємо на масив символів
    .map((letter) => dict[letter]) // Замінюємо кожну літеру словом із словника
    .join(' '); // Об'єднуємо назад у рядок
};
// Цікаві варіанти з Codewars
const makeBackronym_ = (string) =>
  [...string].map((val) => dict[val.toUpperCase()]).join(` `);
// ================================================================================================
// ================================================================================================
//*-Task №824 (7kyu)
/*
Проблема
Джеймс — діджей на місцевій радіостанції. Оскільки наближається кінець години, йому потрібно знайти
пісню, яка буде достатньо короткою, щоб поміститися перед новинним блоком.
У нього є база даних пісень, які він хотів би, щоб ви допомогли йому відфільтрувати для цього.

Що робити
Створіть допоміжну функцію longestPossible, яка приймає 1 цілочисельний аргумент, що є максимальною
тривалістю пісні в секундах.

songs — це масив об'єктів, відформатованих наступним чином:

{artist: 'Artist', title: 'Title String', playback: '04:30'}
Ви можете очікувати, що значення playback буде відформатовано точно так само, як і вище.

Вивід має бути назвою найдовшої пісні з бази даних, яка відповідає критерію не довшої за заданим часом.
Якщо в базі даних немає пісень, що відповідають критеріям, поверніть false.
*/

// Мій варіант
function longestPossible(playback) {
  if (!songs || songs.length === 0) return false;

  // // Конвертируем в секунды
  function toSeconds(time) {
    const [m, s] = time.split(':').map((n) => Number(n));
    return m * 60 + s;
  }

  let resultLength = 0;
  let resultTitle = false;
  songs.forEach((song) => {
    let songLength = toSeconds(song.playback);

    if (songLength < playback && songLength > resultLength) {
      resultLength = songLength;
      resultTitle = song.title;
    }
  });
  return resultTitle;
}
// Цікаві варіанти з Codewars
function longestPossible_(playback) {
  function getTime(song) {
    return song.playback.substr(0, 2) * 60 + +song.playback.substr(3, 2);
  }

  var song = {};
  song.playback = '00:00';

  songs.forEach(function (val, index) {
    if (playback >= getTime(val) && getTime(val) > getTime(song)) {
      song = val;
    }
  });

  return getTime(song) ? song.title : false;
}
// ================================================================================================
// ================================================================================================
//*-Task №825 Ghostbusters (whitespace removal) (7kyu)
/*
О ні! Повідомляється, що місто заполонили привиди. Ваше завдання – позбутися їх і врятувати становище!
У цьому ката рядки представляють будівлі, а пробіли всередині цих рядків – привидів.
Тож чого ви чекаєте? Поверніть будівлю (рядок) без будь-яких привидів (пробілів)!

Приклад:

"Sky scra per" -> "Skyscraper"
Якщо будівля не містить привидів, поверніть рядок:
*/

// Мій варіант
function ghostBusters(building) {
  if (!building.includes(' ')) {
    return "You just wanted my autograph didn't you?";
  }
  return building.split(' ').join('');
}
// Цікаві варіанти з Codewars
function ghostBusters_(building) {
  return /\s/.test(building)
    ? building.replace(/\s+/g, '')
    : "You just wanted my autograph didn't you?";
}
// ================================================================================================
// ================================================================================================
//*-Task №826 (whitespace removal) (7kyu)
/*
Напишіть функцію, яка приймає рядок дужок та визначає, чи порядок дужок є правильним.
Функція повинна повертати true, якщо рядок правильний, та false, якщо він недійсний.

Приклади
"()" => true
")(()))" => false
"(" => false
"())((()()()())" => true
Обмеження
0 <= довжина вхідних даних <= 100

Усі вхідні дані будуть рядками, що складаються лише з символів ( та ).
Пусті рядки вважаються збалансованими (і тому правильними) і будуть перевірені.
Для мов зі змінними рядками вхідні дані не повинні бути змінені.

Порада: Якщо ви намагаєтеся з'ясувати, чому рядок дужок є недійсним, вставте дужки в редактор коду
та дозвольте підсвічуванню коду показати вам це!
*/

// Мій варіант
function validParentheses(parens) {
  const stack = [];

  for (let char of parens) {
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.length === 0) {
        return false;
      }
      stack.pop();
    }
  }

  return stack.length === 0;
}

// Цікаві варіанти з Codewars
function validParentheses_(a) {
  while (a.includes('()')) {
    a = a.replace(/\(\)/g, '');
  }
  return a === '';
}
// ================================================================================================
// ================================================================================================
//*-Task №827 Coding Meetup #12 - Higher-Order Functions Series - Find GitHub admins (7kyu)
/*
Вам буде надано масив об'єктів, що представляють дані про розробників, які зареєструвалися для
участі в наступній зустрічі з програмування, яку ви організовуєте.

Враховуючи наступний вхідний масив:
var list1 = [
  { firstName: 'Harry', lastName: 'K.', country: 'Brazil', continent: 'Americas', age: 22, language: 'JavaScript', githubAdmin: 'yes' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 49, language: 'Ruby', githubAdmin: 'no' },
  { firstName: 'Jing', lastName: 'X.', country: 'China', continent: 'Asia', age: 34, language: 'JavaScript', githubAdmin: 'yes' },
  { firstName: 'Piotr', lastName: 'B.', country: 'Poland', continent: 'Europe', age: 128, language: 'JavaScript', githubAdmin: 'no' }
];

напишіть функцію, яка при виконанні як findAdmin(list1, 'JavaScript') повертає лише розробників JavaScript,
які є адміністраторами GitHub:
[
  { firstName: 'Harry', lastName: 'K.', country: 'Brazil', continent: 'Americas', age: 22, language: 'JavaScript', githubAdmin: 'yes' },
  { firstName: 'Jing', lastName: 'X.', country: 'China', continent: 'Asia', age: 34, language: 'JavaScript', githubAdmin: 'yes' }
]

Примітки:

Початковий порядок слід зберегти.
Якщо для певної мови немає розробників-адміністраторів GitHub, тоді повертається порожній масив [].
Вхідний масив завжди буде дійсним та відформатованим, як у наведеному вище прикладі.
Рядки, що вказують на те, чи є хтось адміністратором GitHub, завжди будуть відформатовані як «так» та «ні» (усі у нижньому регістрі).
Рядки, що представляють певну мову, завжди будуть відформатовані однаково
(наприклад, «JavaScript» завжди буде відформатовано з використанням великих літер «J» та «S».
*/

// Мій варіант
function findAdmin(list, lang) {
  return list.filter(
    (obj) => obj.language === lang && obj.githubAdmin === 'yes'
  );
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №828 Complete Series (7kyu)
/*
Вам задано масив невід'ємних цілих чисел.
Ваше завдання — завершити ряд від 0 до найбільшого числа в масиві.

Якщо числа у наданій послідовності не в порядку, ви повинні їх упорядкувати, але якщо значення
повторюється, тоді ви повинні повернути послідовність лише з одним елементом, значення якого має бути 0.
Ось так:

входи виходи
[2,1] -> [0,1,2]
[1,4,4,6] -> [0]
Примітки: всі числа є додатними цілими числами.

Це набір прикладів виходів на основі вхідної послідовності.

входи виходи
[0,1] -> [0,1]
[1,4,6] -> [0,1,2,3,4,5,6]
[3,4,5] -> [0,1,2,3,4,5]
[0,1,0] -> [0]
*/

// Мій варіант
function completeSeries(arr) {
  // Перевірка на дублікати
  if (new Set(arr).size !== arr.length) {
    return [0];
  }

  // Знайти максимум
  const max = Math.max(...arr);
  // Повернути послідовність від 0 до max
  return Array.from({ length: max + 1 }, (_, i) => i);
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №829 Multiply array values and filter non-numeric (7kyu)
/*
Ваше завдання — написати функцію, яка приймає два аргументи та повертає послідовність.
Перший аргумент — це послідовність значень, другий — множник. Функція повинна фільтрувати всі
нечислові значення та множити решту на заданий множник.
*/

// Мій варіант
function multiplyAndFilter(array, multiplier) {
  return array.filter((a) => typeof a == 'number').map((a) => a * multiplier);
}
// Цікаві варіанти з Codewars
const multiplyAndFilter_ = (array, multiplier) =>
  array.filter((a) => typeof a == 'number').map((a) => a * multiplier);
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
