//*-Task №821 Simple fibonacci strings (7kyu)
/*
Враховуючи, що

f0 = '0'
f1 = '01'
f2 = '010' = f1 + f0
f3 = '01001' = f2 + f1
Вам буде задано число, і ваше завдання — повернути n-й рядок Фібоначчі. Наприклад:

solve(2) = '010'
solve(3) = '01001'
Більше прикладів у тестових випадках. Удачі!

Якщо вам подобаються послідовні ката, вам сподобається цей ката: Simple Prime Streaming
*/

// Мій варіант
function solve(n) {
  if (n === 0) return '0';
  if (n === 1) return '01';
  let a = '0'; // f0
  let b = '01'; // f1
  for (let i = 2; i <= n; i++) {
    const c = b + a; // fn = f(n-1) + f(n-2)
    a = b;
    b = c;
  }
  return b;
}
// Цікаві варіанти з Codewars
const solve_ = (n) =>
  n === 0 ? '0' : n === 1 ? '01' : solve(n - 1) + solve(n - 2);
// ================================================================================================
// ================================================================================================
//*-Task №822 Determine if the poker hand is flush (7kyu)
/*
Визначити, чи є покерна рука флешем, тобто чи п'ять карт однієї масті.

Вашій функції буде передано масив із 5 рядків, кожен з яких представляє покерну карту у
форматі "5H" (5 червів), що означає значення карти, а потім початкову літеру її масті
(Hearts, Spades, Diamonds or Clubs). Джокерів не враховувати.

Ваша функція повинна повернути значення true, якщо рука флеш, в іншому випадку значення false.

Можливі значення карт: 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A

Приклади
["AS", "3S", "9S", "KS", "4S"]  ==> true

["AD", "4S", "7H", "KS", "10S"] ==> false
*/

// Мій варіант
function isFlush(cards) {
  for (let i = 1; i < cards.length; i++) {
    if (cards[0][cards[0].length - 1] !== cards[i][cards[i].length - 1]) {
      return false;
    }
  }
  return true;
}
// Цікаві варіанти з Codewars
function isFlush_(cards) {
  return cards.every((a) => cards[0].slice(-1) === a.slice(-1));
}
// ================================================================================================
// ================================================================================================
//*-Task №823 makeBackronym (7kyu)
/*
Акронім, навмисно утворений з фрази, початкові літери якої позначають певне слово або слова,
або для створення назви, що запам'ятовується, або як вигадливе пояснення походження слова.

"Біорізноманіття, що служить нашій нації", або BISON

(з https://en.oxforddictionaries.com/definition/backronym)

Заповніть функцію для створення бекронімів. Перетворіть заданий рядок (без пробілів) на бекронім,
використовуючи попередньо завантажений словник, і поверніть рядок слів, розділених одним пробілом
(але без пробілів у кінці).

Ключі попередньо завантаженого словника - це великі літери A-Z, а значення - заздалегідь визначені
слова, наприклад:
dict["P"] == "perfect"
Examples
"dgm" ==> "disturbing gregarious mustache"

"lkj" ==> "literal klingon joke"
*/

// Мій варіант
var makeBackronym = function (string) {
  return string
    .toUpperCase() // Перетворюємо на великі літери
    .split('') // Розбиваємо на масив символів
    .map((letter) => dict[letter]) // Замінюємо кожну літеру словом із словника
    .join(' '); // Об'єднуємо назад у рядок
};
// Цікаві варіанти з Codewars
const makeBackronym_ = (string) =>
  [...string].map((val) => dict[val.toUpperCase()]).join(` `);
// ================================================================================================
// ================================================================================================
//*-Task №824 (7kyu)
/*
Проблема
Джеймс — діджей на місцевій радіостанції. Оскільки наближається кінець години, йому потрібно знайти
пісню, яка буде достатньо короткою, щоб поміститися перед новинним блоком.
У нього є база даних пісень, які він хотів би, щоб ви допомогли йому відфільтрувати для цього.

Що робити
Створіть допоміжну функцію longestPossible, яка приймає 1 цілочисельний аргумент, що є максимальною
тривалістю пісні в секундах.

songs — це масив об'єктів, відформатованих наступним чином:

{artist: 'Artist', title: 'Title String', playback: '04:30'}
Ви можете очікувати, що значення playback буде відформатовано точно так само, як і вище.

Вивід має бути назвою найдовшої пісні з бази даних, яка відповідає критерію не довшої за заданим часом.
Якщо в базі даних немає пісень, що відповідають критеріям, поверніть false.
*/

// Мій варіант
function longestPossible(playback) {
  if (!songs || songs.length === 0) return false;

  // // Конвертируем в секунды
  function toSeconds(time) {
    const [m, s] = time.split(':').map((n) => Number(n));
    return m * 60 + s;
  }

  let resultLength = 0;
  let resultTitle = false;
  songs.forEach((song) => {
    let songLength = toSeconds(song.playback);

    if (songLength < playback && songLength > resultLength) {
      resultLength = songLength;
      resultTitle = song.title;
    }
  });
  return resultTitle;
}
// Цікаві варіанти з Codewars
function longestPossible_(playback) {
  function getTime(song) {
    return song.playback.substr(0, 2) * 60 + +song.playback.substr(3, 2);
  }

  var song = {};
  song.playback = '00:00';

  songs.forEach(function (val, index) {
    if (playback >= getTime(val) && getTime(val) > getTime(song)) {
      song = val;
    }
  });

  return getTime(song) ? song.title : false;
}
// ================================================================================================
// ================================================================================================
//*-Task №825 Ghostbusters (whitespace removal) (7kyu)
/*
О ні! Повідомляється, що місто заполонили привиди. Ваше завдання – позбутися їх і врятувати становище!
У цьому ката рядки представляють будівлі, а пробіли всередині цих рядків – привидів.
Тож чого ви чекаєте? Поверніть будівлю (рядок) без будь-яких привидів (пробілів)!

Приклад:

"Sky scra per" -> "Skyscraper"
Якщо будівля не містить привидів, поверніть рядок:
*/

// Мій варіант
function ghostBusters(building) {
  if (!building.includes(' ')) {
    return "You just wanted my autograph didn't you?";
  }
  return building.split(' ').join('');
}
// Цікаві варіанти з Codewars
function ghostBusters_(building) {
  return /\s/.test(building)
    ? building.replace(/\s+/g, '')
    : "You just wanted my autograph didn't you?";
}
// ================================================================================================
// ================================================================================================
//*-Task №826 (whitespace removal) (7kyu)
/*
Напишіть функцію, яка приймає рядок дужок та визначає, чи порядок дужок є правильним.
Функція повинна повертати true, якщо рядок правильний, та false, якщо він недійсний.

Приклади
"()" => true
")(()))" => false
"(" => false
"())((()()()())" => true
Обмеження
0 <= довжина вхідних даних <= 100

Усі вхідні дані будуть рядками, що складаються лише з символів ( та ).
Пусті рядки вважаються збалансованими (і тому правильними) і будуть перевірені.
Для мов зі змінними рядками вхідні дані не повинні бути змінені.

Порада: Якщо ви намагаєтеся з'ясувати, чому рядок дужок є недійсним, вставте дужки в редактор коду
та дозвольте підсвічуванню коду показати вам це!
*/

// Мій варіант
function validParentheses(parens) {
  const stack = [];

  for (let char of parens) {
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.length === 0) {
        return false;
      }
      stack.pop();
    }
  }

  return stack.length === 0;
}

// Цікаві варіанти з Codewars
function validParentheses_(a) {
  while (a.includes('()')) {
    a = a.replace(/\(\)/g, '');
  }
  return a === '';
}
// ================================================================================================
// ================================================================================================
//*-Task №827 Coding Meetup #12 - Higher-Order Functions Series - Find GitHub admins (7kyu)
/*
Вам буде надано масив об'єктів, що представляють дані про розробників, які зареєструвалися для
участі в наступній зустрічі з програмування, яку ви організовуєте.

Враховуючи наступний вхідний масив:
var list1 = [
  { firstName: 'Harry', lastName: 'K.', country: 'Brazil', continent: 'Americas', age: 22, language: 'JavaScript', githubAdmin: 'yes' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 49, language: 'Ruby', githubAdmin: 'no' },
  { firstName: 'Jing', lastName: 'X.', country: 'China', continent: 'Asia', age: 34, language: 'JavaScript', githubAdmin: 'yes' },
  { firstName: 'Piotr', lastName: 'B.', country: 'Poland', continent: 'Europe', age: 128, language: 'JavaScript', githubAdmin: 'no' }
];

напишіть функцію, яка при виконанні як findAdmin(list1, 'JavaScript') повертає лише розробників JavaScript,
які є адміністраторами GitHub:
[
  { firstName: 'Harry', lastName: 'K.', country: 'Brazil', continent: 'Americas', age: 22, language: 'JavaScript', githubAdmin: 'yes' },
  { firstName: 'Jing', lastName: 'X.', country: 'China', continent: 'Asia', age: 34, language: 'JavaScript', githubAdmin: 'yes' }
]

Примітки:

Початковий порядок слід зберегти.
Якщо для певної мови немає розробників-адміністраторів GitHub, тоді повертається порожній масив [].
Вхідний масив завжди буде дійсним та відформатованим, як у наведеному вище прикладі.
Рядки, що вказують на те, чи є хтось адміністратором GitHub, завжди будуть відформатовані як «так» та «ні» (усі у нижньому регістрі).
Рядки, що представляють певну мову, завжди будуть відформатовані однаково
(наприклад, «JavaScript» завжди буде відформатовано з використанням великих літер «J» та «S».
*/

// Мій варіант
function findAdmin(list, lang) {
  return list.filter(
    (obj) => obj.language === lang && obj.githubAdmin === 'yes'
  );
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №828 Complete Series (7kyu)
/*
Вам задано масив невід'ємних цілих чисел.
Ваше завдання — завершити ряд від 0 до найбільшого числа в масиві.

Якщо числа у наданій послідовності не в порядку, ви повинні їх упорядкувати, але якщо значення
повторюється, тоді ви повинні повернути послідовність лише з одним елементом, значення якого має бути 0.
Ось так:

входи виходи
[2,1] -> [0,1,2]
[1,4,4,6] -> [0]
Примітки: всі числа є додатними цілими числами.

Це набір прикладів виходів на основі вхідної послідовності.

входи виходи
[0,1] -> [0,1]
[1,4,6] -> [0,1,2,3,4,5,6]
[3,4,5] -> [0,1,2,3,4,5]
[0,1,0] -> [0]
*/

// Мій варіант
function completeSeries(arr) {
  // Перевірка на дублікати
  if (new Set(arr).size !== arr.length) {
    return [0];
  }

  // Знайти максимум
  const max = Math.max(...arr);
  // Повернути послідовність від 0 до max
  return Array.from({ length: max + 1 }, (_, i) => i);
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №829 Multiply array values and filter non-numeric (7kyu)
/*
Ваше завдання — написати функцію, яка приймає два аргументи та повертає послідовність.
Перший аргумент — це послідовність значень, другий — множник. Функція повинна фільтрувати всі
нечислові значення та множити решту на заданий множник.
*/

// Мій варіант
function multiplyAndFilter(array, multiplier) {
  return array.filter((a) => typeof a == 'number').map((a) => a * multiplier);
}
// Цікаві варіанти з Codewars
const multiplyAndFilter_ = (array, multiplier) =>
  array.filter((a) => typeof a == 'number').map((a) => a * multiplier);
// ================================================================================================
// ================================================================================================
//*-Task №830 The Power of Exponents (7kyu)
/*
Цей ката базується на: Методі степеня
Створіть метод під назвою power, який приймає два цілі числа та повертає значення першого аргументу, зведене до степеня другого.
На відміну від методу степеня, вам також слід враховувати від'ємні показники.
Ваш розв'язок не буде перевірено на спеціальних випадках, що призводять до невизначених значень.

Примітка: Оператор ** (JS: Math.pow) було вимкнено.

Приклади:

power(2, 3) // 8
power(4, -2) // 0.0625
*/

// Мій варіант
function power(base, exponent) {
  // Обробка показника 0
  if (exponent === 0) {
    return 1;
  }

  // Для від'ємних показників
  if (exponent < 0) {
    return 1 / power(base, -exponent);
  }

  // Для додатних показників
  let result = 1;
  for (let i = 0; i < exponent; i++) {
    result *= base;
  }
  return result;
}
// Цікаві варіанти з Codewars
function power_(base, exp) {
  const pow = (a, b) => (b === 0 ? 1 : a * pow(a, b - 1));
  return exp > 0 ? pow(base, exp) : 1 / pow(base, -exp);
}
// ================================================================================================
// ================================================================================================
//*-Task №831 Diagonals sum (7kyu)
/*
Створіть функцію, яка отримує (квадратну) матрицю та обчислює суму обох діагоналей (головної та додаткової).

Приклад
[ // матриця 3x3
[ 1, 2, 3 ],
[ 4, 5, 6 ],
[ 7, 8, 9 ]
]

// Повинно повернути 30: (1 + 5 + 9) + (3 + 5 + 7)
*/

// Мій варіант
function sum(matrix) {
  const n = matrix.length;
  let sum = 0;

  for (let i = 0; i < n; i++) {
    // Головна діагональ: елементи з однаковими індексами
    sum += matrix[i][i];

    // Додаткова діагональ: елементи, де стовпець = n - 1 - рядок
    sum += matrix[i][n - 1 - i];
  }

  return sum;
}
// Цікаві варіанти з Codewars
const sum_ = (matrix) =>
  matrix.reduce(
    (sum, line, i) => sum + line[i] + line[matrix.length - i - 1],
    0
  );
// ================================================================================================
// ================================================================================================
//*-Task №832 Find the Squares (7kyu)
/*
Задача
Заповніть функцію, яка приймає непарне ціле число (0 < n < 1000000), що є різницею між двома
послідовними ідеальними квадратами, та повертає ці квадрати як рядок у форматі "більший-менший"

Приклади
9 --> "25-16"
5 --> "9-4"
7 --> "16-9"
*/

// Мій варіант
function findSquares(n) {
  const k = (n - 1) / 2;
  const smallerSquare = k * k;
  const largerSquare = (k + 1) * (k + 1);

  return `${largerSquare}-${smallerSquare}`;
}
// Цікаві варіанти з Codewars
function findSquares_(n) {
  const i = (n - 1) / 2;
  return (i + 1) ** 2 + '-' + i ** 2;
}
// ================================================================================================
// ================================================================================================
//*-Task №833 Possibilities Array (7kyu)
/*
Непорожній масив a довжини n називається масивом усіх можливостей, якщо він містить усі числа від 0
до a.length - 1 (включно).
Напишіть функцію, яка приймає цілочисельний масив і повертає true, якщо масив є масивом усіх
можливостей, інакше false.

Приклади:

[1,2,0,3] => True
# Включає всі числа від 0 до a.length - 1 (4 - 1 = 3)

[0,1,2,2,3] => False
# Не включає всі числа від 0 до a.length - 1 (5 - 1 = 4)

[0] => True
# Включає всі числа від 0 до a.length - 1 (1 - 1 = 0).
*/

// Мій варіант
function isAllPossibilities(x) {
  if (!Array.isArray(x) || x.length === 0) {
    return false;
  }

  const n = x.length;
  const uniqueNumbers = new Set(x);

  // Перевіряємо:
  // 1. Кількість унікальних чисел дорівнює довжині масиву
  // 2. Кожне число знаходиться в діапазоні [0, n-1]
  if (uniqueNumbers.size !== n) {
    return false;
  }

  for (let i = 0; i < n; i++) {
    if (!uniqueNumbers.has(i)) {
      return false;
    }
  }

  return true;
}
// Цікаві варіанти з Codewars
function isAllPossibilities_(x) {
  return x.length > 0 ? x.every((a, i) => x.includes(i)) : false;
}
// ================================================================================================
// ================================================================================================
//*-Task №834 Elapsed Seconds (7kyu)
/*
Доповніть функцію так, щоб вона повертала кількість секунд, що минули між заданими часом початку
та часом завершення.

Поради:
Час початку/завершення задається як екземпляри Date (JS/CoffeeScript), DateTime (C#), Time (Nim),
datetime (Python), Time (Ruby) та Data.Time.Clock.UTCTime (Haskell).
Час початку завжди буде перед часом завершення.
*/

// Мій варіант
function elapsedSeconds(startDate, endDate) {
  return Math.floor((endDate - startDate) / 1000);
}

// Цікаві варіанти з Codewars
const elapsedSeconds_ = (sDate, eDate) =>
  (eDate.getTime() - sDate.getTime()) / 1000;
// ================================================================================================
// ================================================================================================
//*-Task №835 Vampire Numbers (7kyu)
/*
Числа вампірів
Наше загальне визначення Чисел вампірів можна описати так:

6 * 21 = 126
# 6 та 21 будуть дійсними «іклами» для числа вампіра, оскільки
# цифри 6, 1 та 2 присутні як у добутку, так і в множниках

10 * 11 = 110
# 110 не є числом вампіра, оскільки в
# множниках є три одиниці, але лише дві одиниці в добутку
Створіть функцію, яка може отримати два «ікла» та визначити, чи є добуток цих двох дійсним числом вампіра.
*/

// Мій варіант
function vampireTest(a, b) {
  const product = a * b;
  const productStr = product.toString();
  const fangsStr = a.toString() + b.toString();

  // Перевіряємо довжину: якщо кількість цифр не співпадає, не може бути числом-вампіром
  if (productStr.length !== fangsStr.length) {
    return false;
  }

  // Сортуємо цифри для порівняння
  const sortedProduct = productStr.split('').sort().join('');
  const sortedFangs = fangsStr.split('').sort().join('');

  // Порівнюємо відсортовані набори цифр
  return sortedProduct === sortedFangs;
}
// Цікаві варіанти з Codewars
var vampire_test_ = function (a, b) {
  var origDigits = String(a) + String(b),
    prodDigits = String(a * b);

  origDigits = origDigits.split('').sort().join('');
  prodDigits = prodDigits.split('').sort().join('');

  return prodDigits === origDigits ? true : false;
};
// ================================================================================================
// ================================================================================================
//*-Task №836 Exclamation marks series #8: Move all exclamation marks to the end of the sentence (7kyu)
/*
Опис:
Перемістити всі знаки оклику в кінець речення

Приклади
"Hi!"          ---> "Hi!"
"Hi! Hi!"      ---> "Hi Hi!!"
"Hi! Hi! Hi!"  ---> "Hi Hi Hi!!!"
"Hi! !Hi Hi!"  ---> "Hi Hi Hi!!!"
"Hi! Hi!! Hi!" ---> "Hi Hi Hi!!!!"
*/

// Мій варіант
function remove(string) {
  // Знайти всі оклики
  const exclamations = (string.match(/!/g) || []).join('');

  // Видалити всі оклики з оригінального рядка
  const withoutExclamations = string.replace(/!/g, '');

  // Додати всі оклики в кінець
  return withoutExclamations + exclamations;
}
// Цікаві варіанти з Codewars
function remove_(s) {
  return s.replace(/!/g, '') + s.replace(/[^!]/g, '');
}
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
