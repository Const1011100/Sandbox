//*-Task №821 Simple fibonacci strings (7kyu)
/*
Враховуючи, що

f0 = '0'
f1 = '01'
f2 = '010' = f1 + f0
f3 = '01001' = f2 + f1
Вам буде задано число, і ваше завдання — повернути n-й рядок Фібоначчі. Наприклад:

solve(2) = '010'
solve(3) = '01001'
Більше прикладів у тестових випадках. Удачі!

Якщо вам подобаються послідовні ката, вам сподобається цей ката: Simple Prime Streaming
*/

// Мій варіант
function solve(n) {
  if (n === 0) return '0';
  if (n === 1) return '01';
  let a = '0'; // f0
  let b = '01'; // f1
  for (let i = 2; i <= n; i++) {
    const c = b + a; // fn = f(n-1) + f(n-2)
    a = b;
    b = c;
  }
  return b;
}
// Цікаві варіанти з Codewars
const solve_ = (n) =>
  n === 0 ? '0' : n === 1 ? '01' : solve(n - 1) + solve(n - 2);
// ================================================================================================
// ================================================================================================
//*-Task №822 Determine if the poker hand is flush (7kyu)
/*
Визначити, чи є покерна рука флешем, тобто чи п'ять карт однієї масті.

Вашій функції буде передано масив із 5 рядків, кожен з яких представляє покерну карту у
форматі "5H" (5 червів), що означає значення карти, а потім початкову літеру її масті
(Hearts, Spades, Diamonds or Clubs). Джокерів не враховувати.

Ваша функція повинна повернути значення true, якщо рука флеш, в іншому випадку значення false.

Можливі значення карт: 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A

Приклади
["AS", "3S", "9S", "KS", "4S"]  ==> true

["AD", "4S", "7H", "KS", "10S"] ==> false
*/

// Мій варіант
function isFlush(cards) {
  for (let i = 1; i < cards.length; i++) {
    if (cards[0][cards[0].length - 1] !== cards[i][cards[i].length - 1]) {
      return false;
    }
  }
  return true;
}
// Цікаві варіанти з Codewars
function isFlush_(cards) {
  return cards.every((a) => cards[0].slice(-1) === a.slice(-1));
}
// ================================================================================================
// ================================================================================================
//*-Task №823 makeBackronym (7kyu)
/*
Акронім, навмисно утворений з фрази, початкові літери якої позначають певне слово або слова,
або для створення назви, що запам'ятовується, або як вигадливе пояснення походження слова.

"Біорізноманіття, що служить нашій нації", або BISON

(з https://en.oxforddictionaries.com/definition/backronym)

Заповніть функцію для створення бекронімів. Перетворіть заданий рядок (без пробілів) на бекронім,
використовуючи попередньо завантажений словник, і поверніть рядок слів, розділених одним пробілом
(але без пробілів у кінці).

Ключі попередньо завантаженого словника - це великі літери A-Z, а значення - заздалегідь визначені
слова, наприклад:
dict["P"] == "perfect"
Examples
"dgm" ==> "disturbing gregarious mustache"

"lkj" ==> "literal klingon joke"
*/

// Мій варіант
var makeBackronym = function (string) {
  return string
    .toUpperCase() // Перетворюємо на великі літери
    .split('') // Розбиваємо на масив символів
    .map((letter) => dict[letter]) // Замінюємо кожну літеру словом із словника
    .join(' '); // Об'єднуємо назад у рядок
};
// Цікаві варіанти з Codewars
const makeBackronym_ = (string) =>
  [...string].map((val) => dict[val.toUpperCase()]).join(` `);
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
