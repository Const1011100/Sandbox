//*-Task №681 The Office II - Boredom Score (7kyu)
/*
Час від часу люди в офісі змінюють команди або відділи. Залежно від того, що люди роблять
зі своїм часом, вони можуть стати більш-менш нудними. Час оцінити нинішню команду.

Вам буде надано об’єкт (персонал), який містить імена співробітників як ключі та відділ,
у якому вони працюють, як значення.

Кожен відділ має різну оцінку нудьги, а саме:

accounts = 1
finance = 2
canteen = 10
regulation = 3
trading = 6
change = 6
IS = 8
retail = 5
cleaning = 4
pissing about = 25

Залежно від сукупного результату команди, поверніть відповідний настрій:

<=80: 'kill me now'
< 100 & > 80: 'i can handle this'
100 or over: 'party time!!'
*/

// Мій варіант
function boredom(staff) {
  const departmentScores = {
    accounts: 1,
    finance: 2,
    canteen: 10,
    regulation: 3,
    trading: 6,
    change: 6,
    IS: 8,
    retail: 5,
    cleaning: 4,
    'pissing about': 25,
  };
  const totalScore = Object.values(staff).reduce((sum, department) => {
    return sum + departmentScores[department] || 0;
  }, 0);
  if (totalScore <= 80) return 'kill me now';
  if (totalScore < 100) return 'i can handle this';
  return 'party time!!';
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №682 Rotate for a Max (7kyu)
/*
Почнемо з прикладу:
Візьміть число: 56789. Поверніть ліворуч, отримаєте 67895.

Залиште першу цифру на місці та поверніть інші цифри вліво: 68957.

Залиште перші дві цифри на місці та поверніть інші: 68579.

Збережіть перші три цифри та поверніть решту вліво: 68597.
Тепер усе закінчено, оскільки зберігаючи перші чотири, залишається лише одна цифра, яка повертається, це сама.

У вас є така послідовність чисел:

56789 -> 67895 -> 68957 -> 68579 -> 68597
і ви повинні повернути найбільше: 68957.

завдання
Напишіть функцію max_rot(n), яка, враховуючи натуральне число n, повертає максимальне число,
яке ви отримали, виконуючи обертання, подібні до наведеного вище прикладу.
Отже, max_rot (або maxRot або ... залежно від мови) виглядає так:
max_rot(56789) має повернути 68957
max_rot(38458215) має повернути 85821534
*/

// Мій варіант
function maxRot(n) {
  let max = n;
  let arr = String(n).split('');
  for (let i = 0; i < arr.length; i++) {
    arr.push(arr.splice(i, 1));
    const num = Number(arr.join(''));
    if (num > max) max = num;
  }
  return max;
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №683 Numbers to Letters (7kyu)
/*
Маючи масив чисел (у форматі рядка), ви повинні повернути рядок.
Цифри відповідають буквам алфавіту в зворотному порядку: a=26, z=1 і т. д.
Також слід враховувати «!», «?» і ' ', які представлені '27', '28' і '29' відповідно.

Усі введені дані будуть дійсними.
*/

// Мій варіант
function switcher(x) {
  const data = {
    1: 'z',
    2: 'y',
    3: 'x',
    4: 'w',
    5: 'v',
    6: 'u',
    7: 't',
    8: 's',
    9: 'r',
    10: 'q',
    11: 'p',
    12: 'o',
    13: 'n',
    14: 'm',
    15: 'l',
    16: 'k',
    17: 'j',
    18: 'i',
    19: 'h',
    20: 'g',
    21: 'f',
    22: 'e',
    23: 'd',
    24: 'c',
    25: 'b',
    26: 'a',
    27: '!',
    28: '?',
    29: ' ',
  };

  const words = [];
  for (let i = 0; i < x.length; i++) {
    words.push(data[x[i]]);
  }
  return words.join('');
}
// Цікаві варіанти з Codewars
const alpha = ' zyxwvutsrqponmlkjihgfedcba!? ';
const switcher_ = (x) => x.map((item) => alpha[item]).join('');
// ================================================================================================
// ================================================================================================
//*-Task №684 Running out of space (7kyu)
/*
Кевін помічає, що його місце закінчилося! Напишіть функцію, яка видаляє пробіли зі значень і
повертає масив, що показує зменшення пробілів.
Наприклад, виконання цієї функції для масиву ['i', 'have','no','space'] призведе до
['i','ihave','ihaveno','ihavenospace']
*/

// Мій варіант
function spacey(array) {
  let result = [];
  for (let i = 0; i < array.length; i++) {
    let joined = array.slice(0, i + 1).join('');
    result.push(joined);
  }
  return result;
}
// Цікаві варіанти з Codewars
function spacey_(array) {
  let string = '';
  return array.map((e) => (string += e));
}
// ================================================================================================
// ================================================================================================
//*-Task №685 Return the first M multiples of N (7kyu)
/*
Реалізуйте функцію, яка приймає два числа m і n і повертає масив перших m кратних дійсного числа n.
Припустимо, що m — натуральне число.
Пр.
(3, 5.0) --> [5.0, 10.0, 15.0]
*/

// Мій варіант
function multiples(m, n) {
  let result = [];
  for (let i = 1; i <= m; i++) {
    result.push(n * i);
  }
  return result;
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №686 A Rule of Divisibility by 7 (7kyu)
/*
Число m виду 10x + y ділиться на 7 тоді і тільки тоді, коли x − 2y ділиться на 7.
Іншими словами, від числа, утвореного рештою цифр, двічі відняти останню цифру.
Продовжуйте робити це, поки не буде отримано число, яке, як відомо, ділиться на 7;
ви можете зупинитися, коли це число має щонайбільше 2 цифри, тому що ви повинні знати, чи число,
що має не більше 2 цифр, ділиться на 7 чи ні.

Вихідне число ділиться на 7 тоді і тільки тоді, коли останнє число, отримане за допомогою цієї процедури,
ділиться на 7.

приклади:
1 - m = 371 -> 37 − (2×1) -> 37 − 2 = 35 ; таким чином, оскільки 35 ділиться на 7, 371 ділиться на 7.

Кількість кроків для отримання результату - 1.

2 - m = 1603 -> 160 - (2 x 3) -> 154 -> 15 - 8 = 7 і 7 ділиться на 7.

3 - m = 372 -> 37 − (2×2) -> 37 − 4 = 33 ; таким чином, оскільки 33 не ділиться на 7, 372 не ділиться на 7.

4 - m = 477557101->47755708->4775554->477547->47740->4774->469->28 і 28 ділиться на 7, отже, 477557101.
Кількість кроків дорівнює 7.

завдання:
Ваше завдання полягає в тому, щоб повернути до функції seven(m) (m integer >= 0) масив
(або пару, залежно від мови) чисел, перше — це останнє число m із щонайбільше 2 цифрами, отримане вашою
функцією (останнє m ділиться чи ні на 7), а друге — кількість кроків, щоб отримати результат.

Четверта примітка:
Повернути в стек кількість-кроків, останнє-число-m-з-найбільше-2-цифрами

приклади:
seven(371) має повернути [35, 1]
seven(1603) має повернути [7, 2]
seven(477557101) має повернути [28, 7]
*/

// Мій варіант
function seven(m) {
  let steps = 0; // Лічильник кроків

  while (m.toString().length > 2) {
    //Поки m має більше ніж 2 цифри
    let lastDigit = m % 10; // Беремо останню цифру (остання справа)
    m = Math.floor(m / 10) - 2 * lastDigit; // Відкидаємо останню цифру і віднімаємо 2 × остання
    steps++; // Збільшуємо лічильник кроків
  }

  return [m, steps]; // Повертаємо фінальне число і кількість кроків
}

// Цікаві варіанти з Codewars
function seven_(m, n = 0) {
  return m < 100 ? [m, n] : seven_(Math.floor(m / 10) - 2 * (m % 10), ++n);
}
// ================================================================================================
// ================================================================================================
//*-Task №687 Folding your way to the moon (7kyu)
/*
Ви чули міф про те, що якщо скласти папір достатньо разів, то з ним можна дістатися до Місяця?
Звичайно, у вас є, але скільки саме? Можливо, настав час написати програму, щоб це зрозуміти.

Ви знаєте, що аркуш паперу має товщину 0,0001м. Дано відстань у метрах, обчисліть,
скільки разів вам потрібно скласти папір, щоб досягти цієї відстані.
(Якщо ви не знайомі з концепцією складання паперу: кожна складка подвоює його загальну товщину.)

Примітка: звичайно, ви не можете зробити половину складки. Ви повинні знати, що це означає ;P

Крім того, якщо хтось дає вам негативну відстань, це явно фальшиво, і ви повинні кричати на них,
повернувши null.
*/

// Мій варіант
function foldTo(distance) {
  if (distance < 0) {
    return null;
  }
  let paper = 0.0001;
  let counter = 0;
  while (paper < distance) {
    paper = paper * 2;
    counter++;
  }
  return counter;
}
// Цікаві варіанти з Codewars
const THICKNESS = 0.0001;

function foldTo_(distance) {
  if (distance < 0) {
    return null;
  }
  if (distance < THICKNESS) {
    return 0;
  }
  return Math.ceil(Math.log2(distance / THICKNESS));
}
// ================================================================================================
// ================================================================================================
//*-Task №688 All Inclusive? (7kyu)
/*
введення:

рядок strng
масив рядків обр
Вихід функції contain_all_rots(strng, arr) (або containAllRots або contain-all-rots):

логічне значення true, якщо всі повороти strng включені в arr
false інакше
приклади:
contain_all_rots(
 "bsjq", ["bsjq", "qbsj", "sjqb", "twZNsslC", "jqbs"]) -> правда

contain_all_rots(
 "Ajylvpy", ["Ajylvpy", "ylvpyAj", "jylvpyA", "lvpyAjy", "pyAjylv", "vpyAjyl", "ipywee"]) -> false)
Примітка:
Хоча некоректно в математичному сенсі

будемо вважати, що поворотів strng == "" немає
і для будь-якого масиву arr: contain_all_rots("", arr) --> true
*/

// Мій варіант
function containAllRots(strng, arr) {
  if (strng === '') {
    return true;
  }

  let rotations = [];
  // Генеруємо всі можливі повороти рядка strng
  for (let i = 0; i < strng.length; i++) {
    let rotated = strng.slice(i) + strng.slice(0, i);
    rotations.push(rotated);
  }

  // Перевіряємо, чи всі згенеровані повороти є в масиві arr
  for (let rotation of rotations) {
    if (!arr.includes(rotation)) {
      return false;
    }
  }

  return true;
}

// Цікаві варіанти з Codewars
function containAllRots_(str, arr) {
  for (var i = 0; i < str.length; i++) {
    if (arr.indexOf(str.slice(i) + str.slice(0, i)) === -1) {
      return false;
    }
  }
  return true;
}
// ================================================================================================
// ================================================================================================
//*-Task №689 Product Array (Array Series #5) (7kyu)
/*
Маючи масив цілих чисел, побудуйте масив добутків такого ж розміру, щоб prod[i] дорівнював добутку
всіх елементів.

Примітки
Розмір масиву становить принаймні 2 .
Номери масиву будуть лише позитивними
Може статися повторення чисел у масиві.

productArray ({12,20}) ==>  return {20,12}
productArray ({1,5,2}) ==> return {10,2,5}
productArray ({10,3,5,6,2}) return ==> {180,600,360,300,900}
*/

// Мій варіант
function productArray(numbers) {
  // Ініціалізуємо масив для зберігання результатів добутків
  let prod = [];

  // Знаходимо загальний добуток всіх елементів масиву numbers
  let totalProduct = 1;
  for (let num of numbers) {
    totalProduct *= num;
  }

  // Обчислюємо prod[i] для кожного елементу numbers
  for (let num of numbers) {
    prod.push(totalProduct / num);
  }

  return prod;
}
// Цікаві варіанти з Codewars
function productArray_(numbers) {
  return numbers.map((x) => numbers.reduce((a, b) => a * b) / x);
}
// ================================================================================================
// ================================================================================================
//*-Task №690 [BUG] XCOM-388: Mass spectrometer crashes (7kyu)
/*

*/

// Мій варіант
const Spectrometer = {
  getHeaviest: function (atomicMasses) {
    return atomicMasses.reduce((a, b) => Math.max(a, b), +0);
  },
};
// Цікаві варіанти з Codewars
const Spectrometer_ = {
  getHeaviest: function (atomicMasses) {
    if (atomicMasses.length == 0) {
      return 0;
    }
    var re = 292;
    while (!atomicMasses.includes(re)) {
      re--;
    }
    return re;
  },
};
// ================================================================================================
// ================================================================================================
//*-Task №691 [BUG] XCOM-401: Hand-held scanner does not recognize hazardous materials (7kyu)
/*

*/

// Мій варіант
const HazardScanner = {
  isHazardous: function (A_elerium, A_dilithium) {
    return A_dilithium < A_elerium && (A_dilithium - A_elerium) % 2 !== 0;
  },
  getLedColor: function (A_elerium, A_dilithium) {
    return HazardScanner.isHazardous(A_elerium, A_dilithium)
      ? '#FF0000'
      : '#00FF00';
  },
};
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №692 Find the Missing Number (7kyu)
/*
Нижче було запитання, яке я отримав під час технічної співбесіди на посаду розробника програмного
забезпечення початкового рівня. Я думав опублікувати це тут, щоб усі могли спробувати:

Вам надано невідсортований масив, що містить усі цілі числа від 0 до 100 включно.
Однак одного числа не вистачає. Напишіть функцію для пошуку та повернення цього числа.
Які часові та просторові складності вашого рішення?
*/

// Мій варіант
function missingNo(nums) {
  const sum = nums.reduce((result, num) => (result += num), 0);
  return 5050 - sum;
}
// Цікаві варіанти з Codewars
const missingNo_ = (n) => {
  for (i = 0; i <= 100; i++) {
    if (!n.includes(i)) {
      return i;
    }
  }
};
// ================================================================================================
// ================================================================================================
//*-Task №693 Digital cypher (7kyu)
/*
Digital Cypher присвоює кожній літері алфавіту унікальний номер. Наприклад:
 a  b  c  d  e  f  g  h  i  j  k  l  m
 1  2  3  4  5  6  7  8  9 10 11 12 13
 n  o  p  q  r  s  t  u  v  w  x  y  z
14 15 16 17 18 19 20 21 22 23 24 25 26

Замість літер у зашифрованому слові пишемо відповідну цифру, напр. Слово scout:
 s  c  o  u  t
19  3 15 21 20

Потім до кожної отриманої цифри додаємо послідовні цифри з ключа. Наприклад. Якщо ключ дорівнює 1939:
 s  c  o  u  t
  19  3 15 21 20
 + 1  9  3  9  1
 ---------------
  20 12 18 30 21

  m  a  s  t  e  r  p  i  e  c  e
  13  1 19 20  5 18 16  9  5  3  5
+  1  9  3  9  1  9  3  9  1  9  3
  --------------------------------
  14 10 22 29  6 27 19 18  6  12 8

завдання
Напишіть функцію, яка приймає рядок str і номер ключ та повертає масив цілих чисел, що представляють
закодований str.

Вхід / Вихід
Вхідний рядок str складається лише з малих символів.
Ключове вхідне число є додатним цілим числом.

приклад
Encode("scout",1939);  ==>  [ 20, 12, 18, 30, 21]
Encode("masterpiece",1939);  ==>  [ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8]
*/

// Мій варіант
function encode(str, n) {
  const digits = String(n).split('').map(Number);
  const result = str
    .split('')
    .map((char, i) => char.charCodeAt() - 96 + digits[i % digits.length]);

  return result;
}
// Цікаві варіанти з Codewars
function encode_(str, n) {
  const key = String(n);
  return Array.from(
    str,
    (c, i) => c.charCodeAt(0) - 96 + Number(key[i % key.length])
  );
}
// ================================================================================================
// ================================================================================================
//*-Task №694 Coding Meetup #6 - Higher-Order Functions Series - Can they code in the same language? (7kyu)
/*
Ваше завдання - повернутися або:

true, якщо всі розробники в списку кодують одну мову; або
false інакше.
Наприклад, задано наступний масив введення:
var list1 = [
  { firstName: 'Daniel', lastName: 'J.', country: 'Aruba', continent: 'Americas', age: 42, language: 'JavaScript' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 22, language: 'JavaScript' },
  { firstName: 'Hanna', lastName: 'L.', country: 'Hungary', continent: 'Europe', age: 65, language: 'JavaScript' },
];
*/

// Мій варіант
function isSameLanguage(list) {
  // Отримуємо масив унікальних мов програмування
  let languages = list.map((elem) => elem.language);

  // Перевіряємо, чи всі елементи масиву мають однакову мову програмування
  return languages.every((lang, i, arr) => lang === arr[0]);
}
// Цікаві варіанти з Codewars
function isSameLanguage_(list) {
  return list.every((e) => e.language === list[0].language);
}
// ================================================================================================
// ================================================================================================
//*-Task №695 Cat and Mouse - Easy Version (7kyu)
/*
Вам буде надано рядок, що містить кішку «C» та мишку «m». Решта рядка складатиметься з «.».
Рядок починатиметься з кота та закінчуватиметься мишею.

Вам потрібно з'ясувати, чи може кішка зловити мишу з її поточної позиції.
Кішка може перестрибнути максимум через три символи. Отже:

"C.....m" повертає "Втік!" <-- більше трьох символів між
"C...m" повертає "Спіймано!" <-- оскільки між ними є три символи, кішка може стрибати.
*/

// Мій варіант
function catMouse(x) {
  // Знаходимо позиції кота та миші в рядку
  let catIndex = x.indexOf('C');
  let mouseIndex = x.indexOf('m');

  // Визначаємо відстань між котом та мишею
  let distance = Math.abs(catIndex - mouseIndex);

  // Перевіряємо, чи може кішка зловити мишу (відстань <= 4)
  return distance <= 4 ? 'Caught!' : 'Escaped!';
}
// Цікаві варіанти з Codewars
function catMouse_(x) {
  return x.length <= 5 ? 'Caught!' : 'Escaped!';
}
// ================================================================================================
// ================================================================================================
//*-залишилось 1681шт
// console.time('timer_1');
// console.timeEnd('timer_1');
