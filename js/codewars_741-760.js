//*-Task №741 Formatting decimal places #1 (7kyu)
/*
Кожне число з плаваючою комою має бути відформатовано таким чином, щоб поверталися лише перші два
знаки після коми. Вам не потрібно перевіряти, чи введене число є коректним, оскільки в тестах
використовуються лише коректні числа.

Не округляйте числа! Просто відріжте їх після двох знаків після коми!
Правильні приклади:
32,8493 – це 32,84
14,3286 – це 14,32

Неправильні приклади (наприклад, якщо округлити числа):
32,8493 – це 32,85
14,3286 – це 14,33
*/

// Мій варіант
function twoDecimalPlaces(num) {
  return parseInt(num * 100) / 100;
}
// Цікаві варіанти з Codewars
const twoDecimalPlaces = (number) => Math.trunc(number * 100) / 100;
// ================================================================================================
// ================================================================================================
//*-Task №742 Reverse the bits in an integer (7kyu)
/*
Напишіть функцію, яка перевертає біти в цілому числі.
Наприклад, число 417 у двійковій системі буде 110100001. Перетворення двійкової системи на
інвертовані буде 100001011, що дорівнює 267.
Можна вважати, що число не є від'ємним.
*/

// Мій варіант
function reverseBits(n) {
  const reversN = n.toString(2).split('').reverse().join('');
  return parseInt(reversN, 2);
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №743 shorter concat [reverse longer] (7kyu)
/*
Given 2 strings, a and b, return a string of the form: shorter+reverse(longer)+shorter.
In other words, the shortest string has to be put as prefix and as suffix of the reverse of the longest.
Strings a and b may be empty, but not null (In C# strings may also be null. Treat them as if they are empty.).
If a and b have the same length treat a as the longer producing b+reverse(a)+b
 */

// Мій варіант
function shorterReverseLonger(a, b) {
  if (a.length >= b.length) {
    const c = a.split('').reverse().join('');
    return b + c + b;
  }
  if (a.length < b.length) {
    const c = b.split('').reverse().join('');
    return a + c + a;
  }
}
// Цікаві варіанти з Codewars
function shorter_reverse_longer_(a, b) {
  return a.length >= b.length
    ? b + a.split('').reverse().join('') + b
    : a + b.split('').reverse().join('') + a;
}
// ================================================================================================
// ================================================================================================
//*-Task №744 Find The Duplicated Number in a Consecutive Unsorted List (7kyu)
/*
Вам задано масив з n+1 цілих чисел від 1 до n. Крім того, є одне ціле число-дублікат.
Масив не відсортований.
Прикладом коректного масиву буде [3, 2, 5, 1, 3, 4]. Він містить цілі числа від 1 до 5,
а число 3 є продубльованим. [1, 2, 4, 5, 5] буде некоректним, оскільки в ньому відсутнє число 3.
Ви повинні повернути продубльоване значення як одне ціле число.
 */

// Мій варіант
function findDup(arr) {
  let duplicateValue = 0;
  const uniqueValues = [];
  for (let i = 0; i < arr.length; i++) {
    if (!uniqueValues.includes(arr[i])) {
      uniqueValues.push(arr[i]);
    } else {
      duplicateValue = arr[i];
    }
  }
  return duplicateValue;
}
// Цікаві варіанти з Codewars
function findDup_(arr) {
  arr.sort();

  for (let i = 0; i < arr.length; i += 1) {
    if (arr[i] == arr[i + 1]) {
      return arr[i];
    }
  }
}
// ================================================================================================
// ================================================================================================
//*-Task №745 Max-min arrays (7kyu)
/*
У цьому ката вам буде надано масив унікальних елементів, і ваше завдання — переставити значення так,
щоб за першим максимальним значенням йшло перше мінімальне, потім друге максимальне значення,
потім друге мінімальне значення тощо.

Наприклад:
solve([15,11,10,7,12]) = [15,7,12,10,11]
Перше максимальне значення — 15, а перше мінімальне — 7.
Друге максимальне значення — 12, а друге мінімальне — 10 і так далі.
 */

// Мій варіант
function solve(arr) {
  const sortedArray = arr.sort((a, b) => b - a); // 15, 12, 11, 10, 7
  const result = [];
  let switcher = true;
  let left = 0;
  let rigth = sortedArray.length - 1;
  for (let i = 0; i < sortedArray.length; i++) {
    if (switcher) {
      result.push(sortedArray[left]);
      left++;
      switcher = false;
    } else {
      result.push(sortedArray[rigth]);
      rigth--;
      switcher = true;
    }
  }
  return result;
}
// Цікаві варіанти з Codewars
const solve_ = (arr) =>
  [...Array(arr.sort((a, b) => a - b).length)].map((_, idx) =>
    idx % 2 ? arr.shift() : arr.pop()
  );
// ================================================================================================
// ================================================================================================
//*-Task №746 Count consonants (7kyu)
/*
Завершіть функцію, яка приймає рядок англійського тексту та повертає кількість приголосних у рядку.
Приголосні – це всі літери, що використовуються для написання англійської мови,
за винятком голосних a, e, i, o, u.
 */

// Мій варіант
function consonantCount(str) {
  const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
  let consonantCount = 0;

  for (let char of str.toLowerCase()) {
    if (/^[a-z]$/.test(char) && !vowels.has(char)) {
      consonantCount++;
    }
  }

  return consonantCount;
}
// Цікаві варіанти з Codewars
function consonantCount_(str) {
  return (str.match(/[b-df-hj-np-tv-z]/gi) || []).length;
}
// ================================================================================================
// ================================================================================================
//*-Task №747 Count all the sheep on farm in the heights of New Zealand (7kyu)
/*
Щоп'ятниці та щосуботи ввечері фермер рахує овець, які повертаються на його ферму
(вівці, що повернулися в п'ятницю, залишаються і не йдуть).
Вівці повертаються групами в обидва дні -> Вам буде надано два масиви з цими числами
(один для п'ятниці та один для суботнього вечора). Записи масиву є цілими числами, що дорівнюють нулю або більше - якщо заданий масив порожній, фермер не порахував овець або захворів (ми розглядаємо це як жодну вівцю, яка не повернулася тієї ночі).
Фермер знає, скільки у нього всього овець (третій параметр). Вам потрібно обчислити кількість
втрачених овець (не повернутих на ферму) після остаточного підрахунку овець у суботу.

Приклад 1: Вхід: [1, 2], [3, 4], 15 --> Вихід: 5
Приклад 2: Вхід: [3, 1, 2], [4, 5], 21 --> Вихід: 6
Приклад 3: Вхід: [0], [4, 15], 31 --> Вихід: 12
Приклад 4: Вхід: [], [4], 15 --> Вихід: 11
 */

// Мій варіант
function lostSheep(friday, saturday, total) {
  const fridayTotal = friday.reduce((sum, ship) => {
    return (sum += ship);
  }, 0);
  const saturdayTotal = saturday.reduce((sum, ship) => {
    return (sum += ship);
  }, 0);
  return total - (fridayTotal + saturdayTotal);
}
// Цікаві варіанти з Codewars
function lostSheep_(friday, saturday, total) {
  return friday.concat(saturday).reduce((s, l) => s - l, total);
}
//
const lostSheep__ = (f, s, n) => n - [...f, ...s].reduce((a, b) => a + b, 0);
// ================================================================================================
// ================================================================================================
//*-Task №748 (7kyu)
/*
Ви отримуєте назву міста як рядок, і вам потрібно повернути рядок, який показує, скільки разів
кожна літера зустрічається в рядку, використовуючи зірочки (*).

Наприклад:
"Chicago" --> "c:**,h:*,i:*,a:*,g:*,o:*"
Як бачите, літера c відображається лише один раз, але з двома зірочками.

Повернутий рядок повинен містити лише літери (без тире, пробілів, апострофів тощо).
У виводі не повинно бути пробілів, а різні літери розділяються комою (,), як показано
у наведеному вище прикладі.
Зверніть увагу, що повернутий рядок повинен перераховувати літери в порядку їхньої першої
появи у вихідному рядку.

Більше прикладів:
"Bangkok" --> "b:*,a:*,n:*,g:*,k:**,o:*"
"Las Vegas" --> "l:*,a:**,s:**,v:*,e:*,g:*"
 */

// Мій варіант
function getStrings(city) {
  let arr = city
    .toLowerCase()
    .split('')
    .filter((e) => e !== ' ');

  let counter = {};

  for (let c of arr) {
    counter[c] = (counter[c] || 0) + 1;
  }

  let res = [];

  for (let letter in counter) {
    res.push(letter + ':' + '*'.repeat(counter[letter]));
  }

  return res.join(',');
}
// Цікаві варіанти з Codewars
function getStrings_(city) {
  city = city.toLowerCase();
  let obj = {};
  let str = '';

  for (let elem of city) {
    if (!(elem in obj)) {
      obj[elem] = '*';
    } else {
      obj[elem] += '*';
    }
  }

  for (let key in obj) {
    if (key !== ' ') {
      str += key + ':' + obj[key] + ',';
    }
  }

  return str.substring(0, str.length - 1);
}
// ================================================================================================
// ================================================================================================
//*-Task №749 See You Next Happy Year (7kyu)
/*
Сценарій
Ти прощаєшся зі своїм найкращим другом. До зустрічі наступного щасливого року.
Щасливий рік — це рік, у якому лише окремі цифри, (наприклад) 2018

Завдання
Якщо дано рік, знайдіть наступний щасливий рік або найближчий рік, коли ви побачите свого найкращого друга.

Примітки
Рік, звичайно, завжди додатний.
Не бійтеся, відповідь гарантовано існує.
Не обов'язково, щоб рік, переданий функції, був щасливим.
Введіть рік у діапазоні (1000 ≤ y ≤ 9000)

nextHappyYear (7712) ==> return (7801)
nextHappyYear (8989) ==> return (9012)
nextHappyYear (1001) ==> return (1023)
 */

// Мій варіант
function nextHappyYear(year) {
  for (let i = year + 1; i <= 10000; i++) {
    const arr = `${i}`.split('');
    const uniqueElements = new Set(arr);
    const newArray = Array.from(uniqueElements);
    if (newArray.length === 4) {
      return Number(newArray.join(''));
    }
  }
}
// Цікаві варіанти з Codewars
function nextHappyYear_(a) {
  while (new Set([...(++a + '')]).size < 4);
  return a;
}
// ================================================================================================
// ================================================================================================
//*-Task №750 Numbers to Objects (7kyu)
/*
Вам буде надано масив чисел.
Для кожного числа в масиві вам потрібно буде створити об'єкт.
Ключем об'єкта буде число у вигляді рядка. Значенням буде відповідний код символу у вигляді рядка.
Повернути масив результуючих об'єктів.
Усі вхідні дані будуть масивами чисел. Усі коди символів є допустимими літерами нижнього регістру.
Вхідний масив не буде порожнім.
 */

// Мій варіант
function numObj(s) {
  return s.map((e) => {
    return { [e.toString()]: String.fromCharCode(e).toLocaleLowerCase() };
  });
}
// Цікаві варіанти з Codewars
const numObj_ = ($) => $.map((el) => ({ [el]: String.fromCodePoint(el) }));
// ================================================================================================
// ================================================================================================
//*-Task №751 Who is the killer? (7kyu)
/*
Хто вбивця? Деяких людей убито! Вам вдалося звузити коло підозрюваних до кількох.
На щастя, ви знаєте кожну людину, яку ці підозрювані бачили в день убивств.

Завдання.
Вам надано словник з усіма іменами підозрюваних та всіх, кого вони бачили в той день,
який може виглядати так:
{'James': ['Jacob', 'Bill', 'Lucas'],
 'Johnny': ['David', 'Kyle', 'Lucas'],
 'Peter': ['Lucy', 'Kyle']}

 а також список імен загиблих:
 ['Lucas', 'Bill']

 повернути ім'я одного вбивці, у нашому випадку «Джеймс», оскільки він єдина людина,
 яка бачила і 'Lucas', і 'Bill'
 */

// Мій варіант
function killer(suspectInfo, dead) {
  return Object.keys(suspectInfo).find((suspect) =>
    dead.every((victim) => suspectInfo[suspect].includes(victim))
  );
}
// Цікаві варіанти з Codewars
function killer_(suspectInfo, dead) {
  //your code here...
  for (let name in suspectInfo) {
    if (dead.every((deadPerson) => suspectInfo[name].includes(deadPerson))) {
      return name;
    }
  }
}
// ================================================================================================
// ================================================================================================
//*-Task №752 Help Bob count letters and digits. (7kyu)
/*
Боб — лінивець.
Йому потрібно, щоб ви створили метод, який може визначити, скільки літер (як великих, так і малих ASCII)
та цифр міститься в заданому рядку.

Приклад:
"hel2!lo" --> 6
"wicked .. !" --> 6
"!?..A" --> 1
 */

// Мій варіант
function countLettersAndDigits(input) {
  return input.match(/[a-zA-Z0-9]/g) === null
    ? 0
    : input.match(/[a-zA-Z0-9]/g).length;
}
// Цікаві варіанти з Codewars
function countLettersAndDigits_(s) {
  return s.replace(/[^a-z\d]/gi, '').length;
}
//
function countLettersAndDigits__(input) {
  let o = input.match(/[a-z\d]/gi);
  return o !== null ? o.length : 0;
}
// ================================================================================================
// ================================================================================================
//*-Task №753 Pull your words together, man! (7kyu)
/*
Ваш друг Роббі успішно створив штучний інтелект, здатний спілкуватися англійською!

Роббі майже завершив проєкт, проте результати роботи машини не працюють належним чином.
Ось приклад речення, яке вона виводить:

["this","is","a","sentence"]
Щоразу, коли машина намагається вимовити речення, замість форматування його у звичайній англійській
орфографії, вона просто виводить список слів.

Роббі провів кілька ночей, щоб завершити цей проєкт, і йому потрібен гарний сон. Тому він хоче,
щоб ви написали останню частину його коду, функцію sentencify, яка бере результати роботи машини та форматує їх у правильну англійську орфографію.

Ваша функція повинна:
Написати першу літеру першого слова з великої літери.
Додати крапку (.) у кінці речення.
Об'єднати слова в повний рядок з пробілами.
Не робити жодних інших маніпуляцій зі словами.
 */

// Мій варіант
function sentencify(words) {
  return (
    words
      .map((word, i, arr) => {
        if (i === 0) {
          return word[0].toUpperCase() + word.slice(1);
        }
        return word;
      })
      .join(' ') + '.'
  );
}
// Цікаві варіанти з Codewars
function sentencify_(words) {
  return words.join(' ').replace(/^[a-z]/, (m) => m.toUpperCase()) + '.';
}
//
function sentencify__(words) {
  var str = words.join(' ');
  return str.charAt(0).toUpperCase() + str.substr(1) + '.';
}
// ================================================================================================
// ================================================================================================
//*-Task №754 We Have Liftoff (7kyu)
/*
У вас є масив чисел від 1 до n (де 1 <= n <= 10). Масив має бути правильно відформатований для
людини, яка читає зворотний відлік запуску космічного корабля.

На жаль, людина, яка читає зворотний відлік, знає лише рядки. Після правильного сортування
масиву переконайтеся, що він у форматі, який вона може зрозуміти.

Між кожним числом має бути пробіл, а після останнього числа (n) має бути слово 'liftoff!' (старт!).

Приклад:
// Given
instructions = [8,1,10,2,7,9,6,3,4,5]
// Should return
"10 9 8 7 6 5 4 3 2 1 liftoff!"
// Given
instructions = [1,2,4,3,5]
// Should return
"5 4 3 2 1 liftoff!"
 */

// Мій варіант
function liftoff(instructions) {
  return instructions.sort((a, b) => b - a).join(' ') + ' liftoff!';
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №755 Nice Array (7kyu)
/*
Масив Nice визначається як масив, де для кожного значення n у масиві також існує елемент n - 1 або n + 1.
Приклади:
[2, 10, 9, 3] є масивом Nice, тому що

2 = 3 - 1
10 = 9 + 1
3 = 2 + 1
9 = 10 - 1

[4, 2, 3] є масивом Nice, тому що

4 = 3 + 1
2 = 3 - 1
3 = 2 + 1 (або 3 = 4 - 1)

[4, 2, 1] не є масивом Nice, тому що

для n = 4 немає ні n - 1 = 3, ні n + 1 = 5
Напишіть функцію з іменем isNice, яка повертає true, якщо її аргумент масиву є масивом Nice,
інакше false. Порожній масив не вважається масивом Nice.
 */

// Мій варіант
function isNice(arr) {
  if (arr.length === 0) return false; // обробка порожнього масиву

  for (let n of arr) {
    if (!arr.includes(n - 1) && !arr.includes(n + 1)) {
      return false; // знайшли елемент без сусідів - масив не nice
    }
  }
  return true; // всі елементи мають сусідів
}
// Цікаві варіанти з Codewars
function isNice_(arr) {
  return (
    !!arr.length &&
    arr.every((x) => arr.some((y) => y === x - 1 || y === x + 1))
  );
}
//
const isNice__ = (arr) =>
  Boolean(arr.length) &&
  arr.every((e) => arr.includes(e - 1) || arr.includes(e + 1));
// ================================================================================================
// ================================================================================================
//*-Task №756 Convert Hash To An Array (7kyu)
/*
Перетворити хеш на масив. Ні більше, ні менше.

{name: 'Jeremy', age: 24, role: 'Software Engineer'}
слід перетворити на

[["age", 24], ["name", "Jeremy"], ["role", "Software Engineer"]]
Удачі!
 */

// Мій варіант
function convertHashToArray(hash) {
  const keys = Object.keys(hash);
  const values = Object.values(hash);
  const result = keys.map((e, i, a) => {
    return [keys[i], values[i]];
  });
  return result;
}
// Цікаві варіанти з Codewars
const convertHashToArray_ = (o) => Object.entries(o).sort();
//
function convertHashToArray__(hash) {
  let result = [];
  Object.keys(hash)
    .sort()
    .map((item) => result.push([item, hash[item]]));
  return result;
}
// ================================================================================================
// ================================================================================================
//*-Task №757 String Scramble (7kyu)
/*
Дано рядок та масив індексів. Переставте символи рядка так, щоб кожен символ розміщувався на
позиції, визначеній відповідним індексом у масиві.

Приклад
вхід: "abcd", [0, 3, 1, 2]
вихід: "acdb"
Пояснення
Символ 'a' розміщується за індексом 0.
Символ 'b' розміщується за індексом 3.
Символ 'c' розміщується за індексом 1.
Символ 'd' розміщується за індексом 2.

Примітки
Рядок та масив матимуть однакову довжину.

Рядок міститиме допустимі символи (A-Z, a-z або 0-9);
масив міститиме допустимі індекси.
 */

// Мій варіант
function scramble(str, arr) {
  const result = new Array(str.length);
  for (let i = 0; i < str.length; i++) {
    result[arr[i]] = str[i];
  }
  return result.join('');
}
// Цікаві варіанти з Codewars
function scramble_(s, a) {
  return a.map((_, i) => s[a.indexOf(i)]).join``;
}
// ================================================================================================
// ================================================================================================
//*-Task №758 The reject() function (7kyu)
/*
Реалізуйте функцію, яка фільтрує значення масиву, що задовольняють заданий предикат.
reject([1, 2, 3, 4, 5, 6], (n) => n % 2 === 0) => [1, 3, 5]
 */

// Мій варіант
function reject(array, predicate) {
  return array.filter((e) => !predicate(e));
}
// Цікаві варіанти з Codewars

// ================================================================================================
// ================================================================================================
//*-Task №759 Find sum of top-left to bottom-right diagonals (7kyu)
/*
Дано квадратну матрицю (тобто масив підмасивів). Знайдіть суму значень першого значення першого
масиву, другого значення другого масиву, третього значення третього масиву тощо...

Приклади
array = [[1, 2],
         [3, 4]]

diagonal sum: 1 + 4 = 5

array = [[5, 9, 1, 0],
         [8, 7, 2, 3],
         [1, 4, 1, 9],
         [2, 3, 8, 2]]

diagonal sum: 5 + 7 + 1 + 2 = 15
 */

// Мій варіант
function diagonalSum(matrix) {
  return matrix.reduce((sum, num, i) => {
    return (sum += num[i]);
  }, 0);
}
// Цікаві варіанти з Codewars
function diagonalSum_(matrix) {
  var sum = 0;

  for (var i = 0, width = matrix.length; i < width; i++) {
    sum += matrix[i][i];
  }

  return sum;
}
// ================================================================================================
// ================================================================================================
//*-Task №760 Scrolling Text (7kyu)
/*
Давайте створимо текст, що прокручується!

Ваше завдання — виконати функцію, яка приймає рядок і повертає масив з усіма можливими
обертаннями заданого рядка, у верхньому регістрі.

Приклад
scrollingText("codewars") має повернути:
[ "CODEWARS",
  "ODEWARSC",
  "DEWARSCO",
  "EWARSCOD",
  "WARSCODE",
  "ARSCODEW"
  "RSCODEWA",
  "SCODEWAR" ]
 */

// Мій варіант
function scrollingText(text) {
  const result = [];
  const upperText = text.toUpperCase();

  for (let i = 0; i < text.length; i++) {
    const rotated = upperText.slice(i) + upperText.slice(0, i);
    result.push(rotated);
  }

  return result;
}
// Цікаві варіанти з Codewars
function scrollingText_(text) {
  text = text.toUpperCase();

  return [...text].map((_, i) => text.slice(i) + text.slice(0, i));
}
// ================================================================================================
// ================================================================================================
// console.time('timer_1');
// console.timeEnd('timer_1');
